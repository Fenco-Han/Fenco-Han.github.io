<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sso-learning</title>
      <link href="/2019/11/16/sso-learning/"/>
      <url>/2019/11/16/sso-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><code>背景</code></h2><p>​       在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 </p><p>什么是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>?</p><p>单点登录英文全称Single Sign On，简称就是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong> </p><div align="center"><img src="https://yqfile.alicdn.com/721f02ebe06639e6232b59535d6423db75086693.png"></div><p> 如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的定义。 </p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a><code>技术实现</code></h2><p>在说单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的技术实现之前，我们先说一说普通的登录认证机制。</p><div align="center"><img src="https://yqfile.alicdn.com/555f1a6856468578020ea0486f563b3633813050.png"></div><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a><code>同域下的单点登录</code></h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li></ul><div align="center"><img src="https://yqfile.alicdn.com/4e31c204eea22ee07154df928a5ff5350da03d7a.png"></div><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p><h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a><code>不同域下的单点登录</code></h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。</p><div align="center"><img src="https://yqfile.alicdn.com/dcb743204f8a201be53df5338fc34affe5fa1059.png"/></div><p>上图是CAS官网上的标准流程，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p><p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h2><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li><li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li><li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li></ul><p>转载来自：<a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">云栖社区(小忽悠)</a></p>]]></content>
      
      
      <categories>
          
          <category> 积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中更简便的数组处理函数 .map(), .reduce(), .filter()</title>
      <link href="/2019/11/15/simplify-your-javascript-with/"/>
      <url>/2019/11/15/simplify-your-javascript-with/</url>
      
        <content type="html"><![CDATA[<p>如果你刚接触JavaScript可能你还没有听说过<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>。或者听说过，看过别人用过但是自己在实际项目中没有用过。在国内很多开发项目都是需要考虑IE8的兼容，为了兼容很多JavaScript好用的方法和技巧都被埋没了。但是我发现近几年开始，很多开发项目已经完全抛弃了IE这个魔鬼了。如果你不需要兼容古老的IE浏览器了，那就要开始熟悉一下这几个方法来处理数组。</p><blockquote><p>注意这遍文章说的的3个方法其实在很多其他语言都可以使用到，因为这几个方法和使用概念在很多其他语言都是存在的。</p></blockquote><hr><h1 id="map"><a href="#map" class="headerlink" title=".map()"></a>.map()</h1><p>让我用一个简单的例子告诉你如何使用这个方法。假如你现在有多对象的数组数据 - 每一个对象代表着一个员工的信息。现在你想要的最终结果就是取出所有员工的唯一ID值。</p><pre><code class="JAVASCRIPT">  // 员工数据  var employees = [        { id: 20, name: &#39;Captain Piett&#39; },        { id: 24, name: &#39;General Veers&#39; },        { id: 56, name: &#39;Admiral Ozzel&#39; },        { id: 88, name: &#39;Commander Jerjerrod&#39; }      ];// 你想要的结果9[20, 24, 56, 88]</code></pre><p>其实要实现这个结果有很多数组处理方式。传统的处理方法就是先定义一个空数组，然后使用<code>.forEach()</code>，<code>.for(...of)</code>，或者是最简单的<code>.for()</code>来组装ID到你定义的数组里面。</p><p>我们来对比一下传统的处理方式和<code>.map()</code>的区别。</p><p>使用<code>.forEach()</code></p><pre><code class="javascript">var employeeIds = [];employees.forEach(function (employee) {      employeeIds.push(officer.id);    });</code></pre><p>注意使用传统的方式，我们必须有一个预定义的空数组变量才行。但是如果是<code>.map()</code>就会更简单了。</p><pre><code class="javascript">var employeeIds = employees.map(function (employee) {      return employee.id    });</code></pre><p>甚至我们可以用更简洁的方式，使用箭头方法（但是需要ES6支持，Babel，或者TypeScript）。</p><pre><code class="javascript">const employeeIds = employees.map(employee =&gt; employee.id);</code></pre><p>所以<code>.map()</code>到底是怎么运作的呢？这个方法有两个参数，第一是回调方法，第二是可选内容（会在回调方法中做为<code>this</code>）。数组里的<code>每个数值/对象会被循环进入到回调方法</code>里面，然后<code>返回新的数值/对象</code>到结果数组里面。</p><p>注意的是结果数组的长度永远都会和被循环的数组的长度一致。</p><hr><h1 id="reduce"><a href="#reduce" class="headerlink" title=".reduce()"></a>.reduce()</h1><p>与<code>.map()</code>相识，<code>.reduce()</code>也是循环一个回调方法，数组里面的每一个元素对回进入回调方法。区别是回调方法返回的值会被传递到下一个回调方法，如此类推（等同于一个累加器）。</p><p><code>.reduce()</code>里的累加值可以是任何属性的值，包括<code>integer</code>，<code>string</code>，<code>object</code>等等。这个累加值会被实力化或者传递到下一个回调方法。</p><p>来上代码，做个简单的例子！假如你有一个飞机师的数组，数组里面有每个飞机师的工龄。</p><pre><code class="javascript"> var pilots = [     2  {     3   id: 10,     4   name: &quot;Poe Dameron&quot;,     5   years: 14,     6  },         7  {             8   id: 2,                 9   name: &quot;Temmin &#39;Snap&#39; Wexley&quot;,                     10   years: 30,                         11  },                             12  {                                 13   id: 41,                                     14   name: &quot;Tallissan Lintra&quot;,                                         15   years: 16,                                             16  },                                                 17  {18   id: 99,                                                     19   name: &quot;Ello Asty&quot;,                                                         20   years: 22,                                                             21  }22];</code></pre><p>现在我们需要知道所有飞机师累计的总工龄。使用<code>.reduce()</code>就是比吃饭还简单的事情。</p><pre><code>  JAVASCRIPT1var totalYears = pilots.reduce(function (accumulator, pilot) {2  return accumulator + pilot.years;3}, 0);</code></pre><p>注意我这里第二个参数我传了0。第二个参数是一个累加值的初始值。当然如果场景需要这个初始值也可以传入一个变量或者你需要的值。循环了数组里的每一个元素后，reduce方法会返回最终累加后的值（在我们这个例子中就是<code>82</code>）。</p><blockquote><p>例子里面的<code>acc</code>和<code>accumulator</code>就是累加值变量</p></blockquote><p>如果是使用ES6箭头写法，我们可以写的更加优雅简洁。一行就可以搞掂的事情！</p><pre><code class="javascript">const totalYears = pilots.reduce((acc, pilot) =&gt; acc + pilot.years, 0);</code></pre><p>现在如果我们需要找到哪一位是最有经验的飞机师。这种情况我们一样可以使用<code>.reduce()</code>。</p><pre><code class="javascript">var mostExpPilot = pilots.reduce(function (oldest, pilot) {    2  return (oldest.years || 0) &gt; pilot.years ? oldest : pilot;    3}, {});</code></pre><p>这里我把<code>accumulator</code>变量改为<code>oldest</code>代表飞机师里面的老司机。这时候reduce里面的回调方法对比每一个飞机师，每一次飞机师的值进入这个回调方法，工龄更高的就会覆盖<code>oldest</code>变量。最终循环后得到的<code>oldest</code>就是工龄最高的飞机师。</p><p>通过这几个例子，你可以看到使用<code>.reduce()</code>可以简单又优雅的在一个数组里面获取到单个最终值或者对象。</p><hr><h1 id="filter"><a href="#filter" class="headerlink" title=".filter()"></a>.filter()</h1><p>如果你现在的场景是需要在一个数组里面过滤一部分的数据，这个时候<code>.filter()</code>就是你的最好的朋友了。</p><p>我们用回飞机师的数据，并且加入了所属航空公司的值：</p><pre><code class="javascript">var pilots = [    2  {    3   id: 2,    4   name: &quot;Wedge Antilles&quot;,    5   faction: &quot;Rebels&quot;,    6  },        7  {            8   id: 8,                9   name: &quot;Ciena Ree&quot;,                    10   faction: &quot;Empire&quot;,                        11  },                            12  {                                13   id: 40,                                    14   name: &quot;Iden Versio&quot;,                                        15   faction: &quot;Empire&quot;,                                            16  },                                                17  {                                                    18   id: 66,                                                        19   name: &quot;Thane Kyrell&quot;,                                                            20   faction: &quot;Rebels&quot;,                                                                21  }22];</code></pre><p>加入现在我们想分别筛选出<code>Rebels</code>和<code>Empire</code>两个航空公司的飞机师，使用<code>.filter()</code>就是轻而易举的事情！</p><pre><code class="javascript">var rebels = pilots.filter(function (pilot) {    2  return pilot.faction === &quot;Rebels&quot;;    3});4var empire = pilots.filter(function (pilot) {    5  return pilot.faction === &quot;Empire&quot;;    6});</code></pre><p>就这么简单，如果使用箭头方法（ES6）就更加优雅了：</p><pre><code class="javascript"> 1const rebels = pilots.filter(pilot =&gt; pilot.faction === &quot;Rebels&quot;);2const empire = pilots.filter(pilot =&gt; pilot.faction === &quot;Empire&quot;);</code></pre><p>其实原理很简单，只要你的回调方法返回的是<code>true</code>，这个值或者对象就会在新的数组里面了。如果返回的是<code>false</code>就会被过滤掉了。</p><hr><h1 id="结合使用-map-，-reduce-，-filter"><a href="#结合使用-map-，-reduce-，-filter" class="headerlink" title="结合使用 .map()，.reduce()，.filter()"></a>结合使用 .map()，.reduce()，.filter()</h1><p>既然我们刚刚学到的三个函数都是可以用于数组的，并且<code>.map()</code>和<code>.filter()</code>都是返回数组的。那我们就可以串联起来使用。不说多了上代码试试！</p><p>我们用一个有趣一点的数据试验一下，假如现在我们有一个<code>星球大战</code>里面的<code>人物</code>的数组。每个字段的定义如下：</p><blockquote><ul><li><code>Id</code>: 人物唯一ID</li><li><code>name</code>: 人物名字</li><li><code>pilotingScore</code>: 飞行能力指数</li><li><code>shootingScore</code>: 射击能力指数</li><li><code>isForceUser</code>: 是否拥有隔空操控能力</li></ul></blockquote><p>我们的目标：获取<code>拥有隔空操控能力的飞行员的总飞行能力指数</code>。我们先分开一步一步实现这个目标！</p><ul><li>首先我们需要先获取到拥有隔空操控能力的飞行员。</li></ul><pre><code class="javascript">1var jediPersonnel = personnel.filter(function (person) {    2  return person.isForceUser;    3});4// 结果集: [{...}, {...}, {...}] (Luke, Ezra and Caleb)</code></pre><ul><li>这段代码我们获得了3个飞行员对象，分别都是拥有隔空操控能力的飞行员。使用这个对象我们来获取每个飞行员的飞行能力指数值。</li></ul><pre><code class="javascript">1var jediScores = jediPersonnel.map(function (jedi) {    2  return jedi.pilotingScore + jedi.shootingScore;    3});4// 结果: [154, 110, 156]</code></pre><ul><li>获取到每个飞行员的飞行能力指数值后，我们就可以用累加器（<code>.reduce()</code>）获取总飞行能力指数了。</li></ul><pre><code class="javascript">1var totalJediScore = jediScores.reduce(function (acc, score) {    2  return acc + score;    3}, 0);4// 结果: 420</code></pre><p>这里分开实现方式可以达到我们的目标，但是其实我们可以串联起来，可以写的更加简洁又优雅！我们来玩玩更好玩的吧！</p><pre><code class="javascript">1var totalJediScore = personnel2  .filter(function (person) {    3   return person.isForceUser;    4  })5  .map(function (jedi) {    6   return jedi.pilotingScore + jedi.shootingScore;    7  })8  .reduce(function (acc, score) {    9   return acc + score;    10  }, 0);</code></pre><p>这样写是不是很优雅！都被这段代码给美到了！❤️</p><p>如果我们使用箭头写法ES6，就更加优雅了！</p><pre><code class="javascript">1const totalJediScore = personnel2  .filter(person =&gt; person.isForceUser)3  .map(jedi =&gt; jedi.pilotingScore + jedi.shootingScore)4  .reduce((acc, score) =&gt; acc + score, 0);</code></pre><p>哇！代码原来可以写的那么优雅的么？！想不到吧？</p><blockquote><p>其实我们只需要使用<code>.reduce()</code>就可以得到我们的目标结果了，以上例子做为教学例子，所以使用了3个我们学到的函数。</p><p>我们来看看只用<code>.reduce()</code>怎么实现的，来我们一起来刷新一下三观吧！</p></blockquote><pre><code class="javascript">1const totalJediScore = personnel.reduce((acc, person) =&gt; person.isForceUser ? acc + person.pilotingScore + person.shootingScore : acc, 0);</code></pre><p>不敢想象吧？一行就搞定一个功能不是梦！</p><h1 id="为什么抛弃-forEach"><a href="#为什么抛弃-forEach" class="headerlink" title="为什么抛弃 .forEach()?"></a>为什么抛弃 .forEach()?</h1><p>其实我一开始写前端的时候也是一顿撸，来个数组都是撸个for循环，解决一切数组处理问题。但是近几年我开始步入前后端开发，API接口对接。发现数据处理越来越多，如果还是像以前那样什么都用for循环来处理数据，那其实数据处理的代码就会越来越臃肿越来越复杂凌乱。所以我开始抛弃了<code>.forEach()</code>。开始做一个优雅的程序员！</p><p>为什么使用<code>.map()</code>，<code>.filter()</code>，<code>.reduce()</code>写代码更优雅，更美观呢？我们用一个实战例子来对比一下吧。</p><p>假设现在我们对接一个接口，返回的数组里面有两个字段<code>name：人的名称</code>和<code>title：对应的职位</code>。</p><pre><code class="javascript">1var data = [      2  {    3   name: &quot;Jan Dodonna&quot;,    4   title: &quot;General&quot;,    5  },        6  {            7   name: &quot;Gial Ackbar&quot;,                8   title: &quot;Admiral&quot;,                    9  },                        10]</code></pre><p>产品经理给到你的需求是只需要展示这些人的职位称呼。</p><blockquote><p>当然这个时候有一些前端就会说“我只是个小小的前端，后端给我处理吧”。但是，这个接口其实是一个通用的接口，就是获取这些员工的资料的，是在多个地方使用的。如果每一个页面因为需要展示的不一样而要写多一个接口给你，你觉得这样好吗？做为一个优秀的前端工程师🦁️，这种小case你自己就可以很优雅的处理好了。而且，在一个优秀的团队，后端确实是要考虑接口通用性的，这种为了你的方便而给他们带来更臃肿的接口是不可接受的。所以前端这个时候就是要重组数据了。</p></blockquote><p>假设现在产品给你的需求是员工列表展示，要支持只展示员工职称和员工左右信息的两种显示项。这个时候我们就要编写一个数据组装方法来跟进展示要求来改变数据格式。</p><p>因为这个“神马“的需求，我们使用<code>.forEach()</code>来重组数据就相对比较麻烦了，而且代码也会变得臃肿。</p><p>我们忽略了组装数据的方法，直接就当作我们已经写好了一个组装数据的方法为<code>formatElement</code>。如果我们用<code>forEach</code>首先我们就需要定义一个空数组来接收结果。</p><pre><code class="javascript">1var results = [];2data.forEach(function (element) {    3  var formatted = formatElement(element);    4  results.push(formatted);    5});</code></pre><p>所以我们需要两个方法才能实现这个数据结果，但是为什么要写的那么臃肿呢？因为<code>forEach</code>并没有返回值，单单就给你跑个循环，还需要自己<code>push</code>值到预定义的变量里面。其实一个方法就可以完成了，而且重点是一行代码就完事了。</p><p>来使用我们新学的技巧，用<code>.map()</code>来实现就非常简单优雅了。</p><pre><code class="javascript">  JAVASCRIPT1var results = data.map(formatElement);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>你学会了吗？学会了就去尝试用<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>来替换你传统的<code>for</code>循环吧！我保证你的代码会越来越简洁，可读性更高。</p><p>如果你喜欢我的这遍文章，记得继续关注我的博客，下一遍文章我们开学习怎么在JavaScript中使用<code>.some()</code>和<code>.find()</code>。</p><p>坚持做一个优雅的程序员，坚持每天敲代码！</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生经验</title>
      <link href="/2019/11/14/thinking/"/>
      <url>/2019/11/14/thinking/</url>
      
        <content type="html"><![CDATA[<ol><li><p>除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。</p></li><li><p>沉不下心看书，浮躁和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。</p></li><li><p>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p></li><li><p>一个人明白自己能做什么远比自己想做什么重要得多，前者需要给自己设定一个现实的疆域，是一种尽力而为的勤奋，后者是任性催生的热情，往往来自于对世界的无知和自负。一个人，一定要清楚地认识自己。</p></li><li><p>天下没有免费的午餐。想得到任何东西之前都要先问问自己，是否付得起相应的代价。</p></li><li><p>在早上把你叫醒的，不应该是闹钟，不应该是闹钟，而应该是昨天早睡。</p></li><li><p>太用力的人，跑不远，别把人生的马拉松当成百米冲刺；太用力的爱不仅让自己累，也让身边的人累，最终难以圆满。</p></li><li><p>永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。圈子不同，不必强融。</p></li><li><p>一定要去掌控自己的生活，而不要让生活带着你走。</p></li><li><p>蔡康永曾说，你15岁的时候觉得游泳难，放弃游泳，到18岁遇见一个你喜欢的人约你去游泳，你只好说：“我不会耶”。你18岁觉得英语难，放弃英语，你28岁遇到了一份非常好也很适合你但是要求会英语的工作，你只好说“我不会耶”。出来混总是要还的，前期偷懒，后期肯定要花数倍的精力来弥补，更遗憾的是，不一定补得上。人生最可怕的事，是一边后悔一边生活。</p></li><li><p>婚姻里的指责和抱怨不是因为“我爱你”，而是因为“我情绪管理不好”。</p></li></ol><p>指责不是爱，而是婚姻的杀手。</p><ol start="12"><li>父母的话不全是对的，父母的爱不全是无私的。</li><li>成熟不等于世故，知世故而不世故，才是最善良的成熟。</li><li>你其实并没有想象中那么依赖父母，但父母依赖你的程度远远超过于你的想象。</li><li>尽量不给别人添麻烦，别人最好也别麻烦我。这句话不是冷漠，是成熟。</li><li>分开的时候一定要用力告别，因为说再见，也许真的是再也不见。</li><li>当你的学业、工作、生活不顺利的时候，切记不要把爱情当成你的救命稻草。</li><li>我们总是喜欢拿顺其自然来敷衍人生道路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。</li><li>破不说破，知人不评人，知理不争论。</li><li>刻薄嘴欠和幽默是两回事，口无遮拦和坦率是两回事，没有教养和随性是两回事。有事情是要说出来的，不要等着对方去领悟，因为对方不是你，不知道你想要什么，等到最后只能是伤心和失望，尤其是感情。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes_learningng_01</title>
      <link href="/2019/11/13/kubernetes-learningng-01/"/>
      <url>/2019/11/13/kubernetes-learningng-01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kubernetes的介绍"><a href="#1-Kubernetes的介绍" class="headerlink" title="1.Kubernetes的介绍"></a>1.Kubernetes的介绍</h2><h3 id="1-1Kubernetes与Docker"><a href="#1-1Kubernetes与Docker" class="headerlink" title="1.1Kubernetes与Docker"></a>1.1Kubernetes与Docker</h3><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C1.png" alt=""></p><p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC(Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源)有关的容器技术。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C2.png" alt=""></p><p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C3.png" alt=""></p><p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p><p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C4.png" alt=""></p><p>Open Source，开源</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-03f79be8f1c3a859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Solomon Hykes</p><p>不开则已，一开惊人。</p><p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p><p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p><p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-65f6a350d2889e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-dd4eeed33ca1d759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。</p><p>而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化。</strong></p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4790d914c6bbdd53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-79394519ff0633de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>我们具体来看看Docker。Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“<strong>一次构建，到处运行（Build once，run anywhere）</strong>”。</p><p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p><p>想要搞懂Docker，其实看它的两句口号就行。</p><p>第一句，是“<strong>Build, Ship and Run</strong>”。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-ada467dd294a3fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>也就是，“搭建、发送、运行”，三板斧。</p><p>举个例子：</p><p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-853f90a47874564c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p><p>但是，跑来一个老巫婆，教会我一种魔法。</p><p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-753393ea28196c31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5c237217f6bd517d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>怎么样？是不是很神奇？</p><p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p><p>Docker技术的三大核心概念，分别是：</p><p><strong>镜像（Image）</strong></p><p><strong>容器（Container）</strong></p><p><strong>仓库（Repository）</strong></p><p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p><p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p><p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p><p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p><p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9ca3a319ce4d91ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>于是乎，就变成了一个大的公共仓库。</p><p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p><p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p><p>所以，Docker Registry服务对镜像的管理是非常严格的。</p><p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>好了，说完了Docker，我们再把目光转向K8S。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p><p>就在这个时候，K8S出现了。</p><p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f0aa142c93e879de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p><p>这个集群主要包括两个部分：</p><p><strong>一个Master节点（主节点）</strong></p><p><strong>一群Node节点（计算节点）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-cca00815aa29d21c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p><p>深入来看这两种节点。</p><p>首先是<strong>Master节点。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1bc2e7499cbe5dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p><p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p><p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p><p>Controller manager负责管理控制器，相当于“大总管”。</p><p>然后是<strong>Node节点</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3538dfa59c20c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p><p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p><p>Docker，不用说了，创建容器的。</p><p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p><p>Kube-proxy，主要负责为Pod对象提供代理。</p><p>Fluentd，主要负责日志收集、存储与查询。</p><p><strong>另外一种通俗的解释：（可以先往下学习，等学的差不多了，再来看更能理解）</strong></p><p>18张儿童插画让你秒懂Kubernetes</p><p>很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0b0aebb675f9c57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc457f68dfddb846.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。</p><p>每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-01e1f91dc2c50cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0c4f7abbcfb19b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>(Docker)容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。</p><p>对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc6d941e7e393395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。</p><p>就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。</p><p>“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31cf971fbdeb8ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2fa9619ea6e41154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“我是 Phippy。”小应用程序说。</p><p>“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-57696b2530f1b594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9a5206fa58576b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-d816b7b515e39c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。</p><p>但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。</p><p>Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2d75cd71125c0e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢?”</p><p>“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-18849e1d5226165e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。</p><p>通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5a3010b48e9fba80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。</p><p>Kube 船长慈祥地笑了笑：“我正好有一样东西。”</p><p>他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你!”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-e1eab190db313f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>服务告知 Kubernetes 环境的其余部分(包括其他 Pod 和 Replication Controller)你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。</p><p>其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3a92c6383ee31771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了***的朋友。</p><p>有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。</p><p>“你为什么这么伤心呢?”Goldie 问道。</p><p>“我喜欢这个礼物，但我没有地方可以放它!”Phippy 抽噎道。</p><p>但 Goldie 知道该怎么做。“为什么不把它放入卷中呢?”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1cc777d3edf587a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。</p><p>Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴(Goldie 和每个克隆人都同样令人愉悦)。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。</p><p>“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-30ee26dd6873f48d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。</p><p>Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。</p><p>所以 Phippy 从此过上了幸福的生活。</p><p>转自：<a href="https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）" target="_blank" rel="noopener">https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门实践</title>
      <link href="/2019/07/15/docker-introductory-practice/"/>
      <url>/2019/07/15/docker-introductory-practice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>$$</p><h1 id="前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）"><a href="#前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）" class="headerlink" title="前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）"></a>前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）</h1><h1 id="虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）"><a href="#虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）" class="headerlink" title="虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）"></a>虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）</h1><h1 id="本机：192-168-0-5-1-Docker安装与启动"><a href="#本机：192-168-0-5-1-Docker安装与启动" class="headerlink" title="本机：192.168.0.5 1. Docker安装与启动"></a>本机：192.168.0.5 1. Docker安装与启动</h1><p>$$</p></blockquote><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1 安装Docker"></a>1.1 安装Docker</h2><p>​    (1)yum包更新到最新</p><p>  （2）安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper屈都依赖的</p><blockquote><p>​       </p><pre><code> sudo yum install -y  yum-utils devicemapper-persistent-data lvm2</code></pre></blockquote><p>​    (3) 设置yum源为阿里云</p><blockquote><p>​        <code>sudo yum-coonfig-manager --add-repo</code>        </p><p>[]: <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></blockquote><p>​    (4) 安装docker</p><blockquote><p>​        <code>sudo yum install docker-ce</code></p></blockquote><p>​    (5) 查看版本</p><blockquote><p>​        <code>docker -v</code></p></blockquote><h2 id="1-2-设置ustc的镜像"><a href="#1-2-设置ustc的镜像" class="headerlink" title="1.2 设置ustc的镜像"></a>1.2 设置ustc的镜像</h2><p>​    (1) 编辑该文件</p><blockquote><p>​        vi /etc/docker/daemon.json</p></blockquote><p>​    (2) 该文件中输入如下内容：</p><blockquote><p>​       </p><pre><code> {​        “registry-mirrors”:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]​        }</code></pre></blockquote><h2 id="1-3-Docker的启动与停止"><a href="#1-3-Docker的启动与停止" class="headerlink" title="1.3 Docker的启动与停止"></a>1.3 Docker的启动与停止</h2><p>​      <strong>systemctl</strong> 命令是系统服务管理器指令</p><blockquote><p>​        启动docker</p><p>​            systemctl start docker</p><p>​        停止docker</p><p>​            systemctl stop docker</p><p>​        重启docker</p><p>​            systemctl restart docker</p><p>​        查看docker状态</p><p>​            systemctl status docker</p><p>​        开机启动</p><p>​            systemctl enable docker</p><p>​        查看docker概要信息</p><p>​            docker  info</p></blockquote><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><h2 id="2-1-镜像相关命令"><a href="#2-1-镜像相关命令" class="headerlink" title="2.1 镜像相关命令"></a>2.1 镜像相关命令</h2><h3 id="2-1-1-查看镜像"><a href="#2-1-1-查看镜像" class="headerlink" title="2.1.1 查看镜像"></a>2.1.1 查看镜像</h3><blockquote><p>​        docker images</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f93cb5e0123a841f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-2-搜索镜像"><a href="#2-1-2-搜索镜像" class="headerlink" title="2.1.2 搜索镜像"></a>2.1.2 搜索镜像</h3><blockquote><p>​        docker search 镜像名称</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-8b9d9f04b51c22a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-3-拉取镜像"><a href="#2-1-3-拉取镜像" class="headerlink" title="2.1.3 拉取镜像"></a>2.1.3 拉取镜像</h3><blockquote><p>​        docker pull  镜像名称</p></blockquote><p>​        例如  docker  pull  centos:7</p><h3 id="2-1-4-删除镜像"><a href="#2-1-4-删除镜像" class="headerlink" title="2.1.4 删除镜像"></a>2.1.4 删除镜像</h3><blockquote><p>​        docker  rmi  镜像ID</p></blockquote><p>​        删除所有镜像：docker rmi  ‘docker  images  -q’</p><h2 id="2-2-容器相关命令"><a href="#2-2-容器相关命令" class="headerlink" title="2.2 容器相关命令"></a>2.2 容器相关命令</h2><h2 id="2-2-1-查看容器"><a href="#2-2-1-查看容器" class="headerlink" title="2.2.1 查看容器"></a>2.2.1 查看容器</h2><blockquote><p>​        查看正在运行容器：  docker  ps</p><p>​        查看所有容器： docker  ps  -a</p><p>​        查看最后一次运行容器： docker ps -1</p><p>​        查看停止容器： docker ps -f status=exited</p></blockquote><h3 id="2-2-2-创建与启动容器"><a href="#2-2-2-创建与启动容器" class="headerlink" title="2.2.2 创建与启动容器"></a>2.2.2 创建与启动容器</h3><blockquote><p>​        创建容器命令：docker run</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f47a717be5859766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​        (1) 交互式方式创建容器</p><blockquote><p>​            docker  run  -it  –name=容器名称  镜像名称：标签  /bin/bas</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08c91e9104339b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​              此时，创建完毕后直接进入。</p><p>​              进入容器后exit退出，容器状态自动变为exited.</p><p>​        (2) 守护式方式创建容器</p><blockquote><p>​                docker  run  -di  –name=容器名称  镜像名称：标签</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31bd00e3d1c6470b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                此时，创建完毕后未进入容器</p><p>​                登陆守护方式容器：docker exec -it 容器名称（或者ID） /bin/bash</p><p>​                注意：本次创建容器时，即使上面交互式方式创建的容器mycentos已经关闭，此时仍然不能本次容器也为mycentos!!!</p><h3 id="2-2-3-停止与启动容器"><a href="#2-2-3-停止与启动容器" class="headerlink" title="2.2.3 停止与启动容器"></a>2.2.3 停止与启动容器</h3><blockquote><p>​        停止容器：docker  stop  容器名称（或者ID）</p><p>​        启动容器：docker  start  容器名称（或者ID）</p></blockquote><h3 id="2-2-4-文件拷贝"><a href="#2-2-4-文件拷贝" class="headerlink" title="2.2.4 文件拷贝"></a>2.2.4 文件拷贝</h3><blockquote><p>将文件拷贝到容器内：docker  cp  需要拷贝文件或目录  容器名称:容器目录</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1c82c75233452cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>将文件拷贝出容器外：docker  cp  容器名称:容器目录  需要拷贝文件或目录</p></blockquote><h3 id="2-2-5-目录挂载"><a href="#2-2-5-目录挂载" class="headerlink" title="2.2.5 目录挂载"></a>2.2.5 目录挂载</h3><p><img src="https://upload-images.jianshu.io/upload_images/17169295-be3d71e849f42d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-6-查看容器IP地址"><a href="#2-2-6-查看容器IP地址" class="headerlink" title="2.2.6 查看容器IP地址"></a>2.2.6 查看容器IP地址</h3><blockquote><p>​            docker  inspect 容器名称（或者ID）</p></blockquote><p>直接查找到IP地址方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08d215cdd9404acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-7-删除容器"><a href="#2-2-7-删除容器" class="headerlink" title="2.2.7 删除容器"></a>2.2.7 删除容器</h3><blockquote><p>​        docker  rm  容器名称（或者ID）</p></blockquote><p>​        <strong>注意：1. 与删除镜像区别（删除镜像：docker  rmi  镜像ID）</strong></p><p>​                  <strong>2. 在删除镜像时，要把对应全部创建的容器删除才可以删除镜像！</strong></p><h1 id="3-应用部署"><a href="#3-应用部署" class="headerlink" title="3. 应用部署"></a>3. 应用部署</h1><h2 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h2><p>​    （1） 拉取mysql镜像</p><blockquote><p>​                docker  pull centos/mysql-57-centos7</p></blockquote><p>​    （2） 创建容器</p><blockquote><p>​                docker  run  -di  –name=tensquare_mysql  -p  33306:3306  -e  MYSQL_PASSWORD=123456  mysql</p></blockquote><p>​                -p  代表端口映射，格式为  宿主机映射端口：容器运行端口</p><p>​                -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的密码</p><p>​    （3） 进入mysql容器</p><blockquote><p>​                  docker  exec  -it  tensquare_mysql  /bin/bash</p></blockquote><p>​    （4） 登陆mysql</p><blockquote><p>​                mysql  -u  root  -p</p></blockquote><p>​    （5） 远程登陆mysql</p><p>​                连接宿主机IP并指定端口为33306，这样就可以操作容器的3306端口。</p><h2 id="3-2-tomcat部署"><a href="#3-2-tomcat部署" class="headerlink" title="3.2 tomcat部署"></a>3.2 tomcat部署</h2><p>​    （1） 拉取镜像</p><blockquote><p>​                    docker  pull  tomcat:7-jre7</p></blockquote><p>​        (2) 创建容器</p><p>​                    创建容器  -p 表示地址映射</p><blockquote><p>​                    docker  run  -di  –name=mytomcat  -p  9000:8080  -v /usr/local/webapps:/usr/local/tomcat/webapps  tomcat:7-jre7</p></blockquote><p>​      （3） 进入mysql容器</p><blockquote><p>​                    docker  exec  -it  mytomcat  /bin/bash</p></blockquote><p>​      （4） 远程访问：192.168.0.19:9000/index.jsp</p><h2 id="3-3-Nginx部署"><a href="#3-3-Nginx部署" class="headerlink" title="3.3 Nginx部署"></a>3.3 Nginx部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull  nginx</p></blockquote><p>​        (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=mynginx  -p  80:80  nginx</p></blockquote><h2 id="3-4-Redis部署"><a href="#3-4-Redis部署" class="headerlink" title="3.4 Redis部署"></a>3.4 Redis部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull redis</p></blockquote><p>​          (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=myredis  -p  6379:6379  redis</p></blockquote><h1 id="4-迁移与备份"><a href="#4-迁移与备份" class="headerlink" title="4. 迁移与备份"></a>4. 迁移与备份</h1><h2 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1  容器保存为镜像"></a>4.1  容器保存为镜像</h2><blockquote><p>​            docker  commit  mynginx  mynginx_i</p></blockquote><h2 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2  镜像备份"></a>4.2  镜像备份</h2><blockquote><p>​            docker  save  -o  mynginx.tar  mynginx_i</p></blockquote><h3 id="4-3-镜像恢复与迁移"><a href="#4-3-镜像恢复与迁移" class="headerlink" title="4.3  镜像恢复与迁移"></a>4.3  镜像恢复与迁移</h3><blockquote><p>​            docker  load  -i  mynginx.tar</p></blockquote><p>​            -i  输入的文件</p><blockquote><p>​            docker  images  可看到镜像已恢复</p></blockquote><h1 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. Dockerfile</h1><h2 id="5-1-什么是Dockerfile"><a href="#5-1-什么是Dockerfile" class="headerlink" title="5.1 什么是Dockerfile"></a>5.1 什么是Dockerfile</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-a222a077dc4601f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-6bf066c4b2fcff21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-3-使用脚本创建镜像"><a href="#5-3-使用脚本创建镜像" class="headerlink" title="5.3 使用脚本创建镜像"></a>5.3 使用脚本创建镜像</h2><p>​        （1）创建目录</p><blockquote><p>​                mkdir -p /usr/local/dockerjdk8</p></blockquote><p>​        （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器中/usr/local/dockerjdk8目录</p><p>​        （3）在dockerjdk8目录下创建文件Dockerfile    vi  Dockerfile</p><blockquote><p>​                    #依赖镜像名称和ID</p><p>​                    FROM centos7</p><p>​                    #指定镜像创建者</p><p>​                    MAINTAINER FENCO</p><p>​                    #切换工作目录</p><p>​                    WORKDIR  /usr</p><p>​                    RUN  mkdir  /usr/local/java</p><p>​                    #ADD  是相对路径jar,把java添加到容器</p><p>​                    ADD  jdk-8u171-linux-x64.tar.gz  /usr/local/java/</p></blockquote><blockquote><p>​                    #配置java环境变量</p><p>​                    ENV  JAVA_HOME   /usr/local/java/jdk1.8.0_171</p><p>​                    ENV  JRE_HOME   $JAVA_HOME/jre</p><p>​                    ENV  CLASSPATH   $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</p><p>​                    ENV  PATH  $JAVA_HOME/bin:$PATH</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-077f15b821721ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                            <strong>注意：由于创建jdk1.8镜像用到了docker.io/centos镜像，所以必须保证本地有该镜像。</strong></p><p>​             (4) 执行命令构建镜像</p><blockquote><p>​                       在dockerjdk8目录下执行：    docker   build  -t=’jdk1.8’  .           最后面的点，表示该根目录</p></blockquote><p>​            (5) 查看镜像是否建立完成</p><blockquote><p>​                        docker  images</p></blockquote><h1 id="6-Docker私有仓库"><a href="#6-Docker私有仓库" class="headerlink" title="6. Docker私有仓库"></a>6. Docker私有仓库</h1><h2 id="6-1-私有仓库的搭建及配置"><a href="#6-1-私有仓库的搭建及配置" class="headerlink" title="6.1 私有仓库的搭建及配置"></a>6.1 私有仓库的搭建及配置</h2><p>​    （1） 拉取私有仓库镜像</p><blockquote><p>​        docker pull registry</p></blockquote><p>​      (2)  启动私有仓库容器</p><blockquote><p>​            docker  run  -di  –name=registry  -p  5000:5000  registry</p></blockquote><p>​     (3) 用浏览器访问：<a href="http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。" target="_blank" rel="noopener">http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。</a></p><p>  （4）修改daemon.json</p><blockquote><p>​            vi  /etc/docker/daemon.json</p><p>​            添加以下内容并保存退出。</p><p>​            {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>  （5） 重启docker服务</p><blockquote><p>​            systemctl restart  docker</p></blockquote><h2 id="6-2-镜像的上传及下载到私有仓库"><a href="#6-2-镜像的上传及下载到私有仓库" class="headerlink" title="6.2 镜像的上传及下载到私有仓库"></a>6.2 镜像的上传及下载到私有仓库</h2><h3 id="6-2-1镜像的上传"><a href="#6-2-1镜像的上传" class="headerlink" title="6.2.1镜像的上传"></a>6.2.1镜像的上传</h3><p>​    （1） 标记次镜像为私有仓库的镜像</p><blockquote><p>​                docker tag jdk1.8 192.168.0.19:5000/jdk1.8</p></blockquote><p>​      (2) 上传标记镜像</p><blockquote><p>​                首先，上一步重启了docker服务，所以里面的registry容器也需要启动下。</p><p>​                然后执行上传：docker  push  192.168.0.19:5000/jdk1.8</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4e37943897353c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="6-2-2-镜像的下载"><a href="#6-2-2-镜像的下载" class="headerlink" title="6.2.2 镜像的下载"></a>6.2.2 镜像的下载</h3><p><strong>在另外一台虚拟机中安装docker（192.168.0.21）</strong></p><p>​    （1）修改daemon.json</p><blockquote><p>​                vi  /etc/docker/daemon.json</p><p>​                添加以下内容并保存退出。</p><p>​                {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>​    （2） 重启docker服务</p><blockquote><p>​                systemctl restart  docker</p></blockquote><p>​     (3) 下载标记镜像</p><blockquote><p>​                然后执行下载：docker  pull  192.168.0.19:5000/jdk1.8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
