<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>P142LinkedListCycle（II）</title>
      <link href="/2019/12/21/P142LinkedListCycle%EF%BC%88II%EF%BC%89/"/>
      <url>/2019/12/21/P142LinkedListCycle%EF%BC%88II%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><pre><code>输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><pre><code>输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><p>Related Topics：链表        双指针</p><pre><code class="java">    /**     * 方法一：利用哈希表     * 将遍历过的元素保存进去，如果遇到重复的则，return node;     * 没遇到重复的则visited.add(node);     * node往后移动，node = node.next;     */    public class Solution {        public P142LinkedListCycleIi.ListNode detectCycle(P142LinkedListCycleIi.ListNode head) {            Set&lt;ListNode&gt; visited = new HashSet&lt;&gt;();            ListNode node = head;            while (node != null) {                if (visited.contains(node)) {                    return node;                }                visited.add(node);                node = node.next;            }            return null;        }    }</code></pre><pre><code class="java"> /**     * 方法二：Floyd算法     *      */    public class Solution {        //利用快慢指针，先判断是否有环，若有环则返回slow,fast重合位置。        //备注：slow,fast重合位置不一定就是入环节点。        // (环形链表 I)只需要判断是否含有环，        // 而（环形链表 II）,需要返回入环节点。        private ListNode getIntersect(ListNode head) {            ListNode slow = head;            ListNode fast = head;            while (fast != null &amp;&amp; fast.next != null) {                slow = slow.next;                fast = fast.next.next;                if (slow == fast) {                    return slow;                }            }            return null;        }        public ListNode detectCycle(ListNode head) {            if (head == null) {                return null;            }            //获取重合节点            ListNode index = getIntersect(head);            if (index == null) {                return null;            }            //重合节点与head节点同步走时，这一次重合点就是入环口节点。            ListNode start = head;            ListNode end = index;            while (start != end) {                start = start.next;                end = end.next;            }            return start;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P24SwapNodesInPairs</title>
      <link href="/2019/12/20/P24SwapNodesInPairs/"/>
      <url>/2019/12/20/P24SwapNodesInPairs/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><p>Related Topics：链表</p><pre><code class="java">/** *方法一：迭代法 */class Solution {    public ListNode swapPairs(ListNode head) {        //设置哨兵节点prehead,并指定为0，最后直接输出prehead.next即为结果        ListNode prehead = new ListNode(0);        prehead.next = head;        //设置prev指针用来做下标。(最关键的就是prev,因为下面用到的start,end都是从prev来，        // 所以，当改变prev的值时，等下一个循环时，就可以再次进行交换。)        ListNode prev = prehead;        while (prev.next != null &amp;&amp; prev.next.next != null) {            ListNode start = prev.next;            ListNode end = prev.next.next;            //将prehead节点指向end节点，0--&gt;2            prev.next = end;            //第一个节点指向end之后的节点1--&gt;3            start.next = end.next;            //end节点指向第一个节点 2--&gt;1            end.next = start;            //综上：0--&gt;2--&gt;1--&gt;3--&gt;4,这里仅仅只是2和1位置变化了，要继续变化位置            //所以，要将原来prev指针改变位置，进而start,end也会变化。            //我们要变成1--&gt;4--&gt;3,所以1变成原来的0            prev = start;            //这时候根据上面，prev为1的下标，strat = prev.next,则，start为3的下标            //end = prev.next.next,则，end为4的下标。则有一次交换指针开始了。        }        return prehead.next;    }}</code></pre><pre><code class="java">    /**     * 递归方式     * [1,2,3,4,5,6]     */    class Solution {        public ListNode swapPairs(ListNode head) {            //判断为null的话，直接return            if (head == null || head.next == null) {                return head;            }            //1的下标为head,定义2的下标为next;            ListNode next = head.next;            //让1指向f(3,4,5,6,null);            head.next = swapPairs(next.next);            //让2指向1            next.next = head;            //综上2--&gt;1--&gt;f(3,4,5,6,null)            //f(3,4,5,6):4--&gt;3--&gt;f(5,6，null);            //f(5,6):6--&gt;5--&gt;f(null)            //结果：2-&gt;1-&gt;4-&gt;3-&gt;6-&gt;5-&gt;null            return next;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P141LinkedListCycle</title>
      <link href="/2019/12/18/P141LinkedListCycle/"/>
      <url>/2019/12/18/P141LinkedListCycle/</url>
      
        <content type="html"><![CDATA[<h1 id="P141环形链表"><a href="#P141环形链表" class="headerlink" title="P141环形链表"></a>P141环形链表</h1><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><p>Related Topics：链表      双指针</p><pre><code class="java"> /**  * 方法一：利用哈希表，将head一个一个保存至hash,  * 当出现nodesSeen.Contains(head),则出现过该元素，所以有环形链表。  */   public class Solution {       public boolean hasCycle(ListNode head) {           Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();           while (head != null) {               if (nodesSeen.contains(head)) {                   return true;               } else {                   nodesSeen.add(head);               }               head = head.next;           }           return false;       }   }</code></pre><pre><code class="java">    /**     * 方法二：利用双指针，快慢指针。     * 0ms  37.8MB     */   public class Solution {        public boolean hasCycle(ListNode head) {            //如果该链表就一个元素或者两个元素，不够成环，return false;            if (head = null || head.next = null) {                return false;            }            //定义慢指针slow,快指针fast;            ListNode slow = head;            ListNode fast = head.next;            //当slow != fast,则两者都向后移动，否则return true;            while (slow != fast) {                //当slow != fast,这时快指针到头了，所以也没环了，return false;                if (fast == null || fast.next === null) {                    return false;                } else {                slow = slow.next;                fast = fast.next.next;                }            }            return true;        }   }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P21MergeTwoSortedLists</title>
      <link href="/2019/12/18/P21MergeTwoSortedLists/"/>
      <url>/2019/12/18/P21MergeTwoSortedLists/</url>
      
        <content type="html"><![CDATA[<h1 id="P21合并两个有序链表"><a href="#P21合并两个有序链表" class="headerlink" title="P21合并两个有序链表"></a>P21合并两个有序链表</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><pre><code class="java">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p>Related Topics：链表</p><pre><code class="java">/** *方法一： *递归方法：利用mergeTwoLists本身进行递归。 */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if (l1 == null) {            return l2;        }else if (l2 == null) {            return l1;        }else if (l1.val &lt; l2.val) {            l1.next = mergeTwoLists(l1.next,l2);            return l1;        }else {            l2.next = mergeTwoLists(l1,l2.next);            return l2;        }    }}</code></pre><pre><code class="java">/** *方法二：迭代 */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        //设置哨兵节点prehead，并指定为-1        ListNode prehead = new ListNode(-1);         //设置prev指针用来做下标。        ListNode prev = prehead;        while (l1 != null &amp;&amp; l2 != null) {            if (l1.val &lt;= l2.val) {                //则prev.next指向较小的                prev.next = l1;                //由于该l1已经比较过了，所以向后移动一位，l1 = l1.next;                l1 = l1.next;            }else {                prev.next = l2;                l2 = l2.next;            }            //一轮比较结束后，将prev也向后移动一位            prev = prev.next;         }        //全部比较结束后，prev.next 指向不为null的值。        //由于最有一轮比较结束后出现了l1 == null或者l2 == null,        // 所以接下来也就是说某一链表已经没有元素了。        //所以直接将prev.next指向不为null的那个链表就行。        prev.next = l1 == null ? l2 : l1;        return prehead.next;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P15ThreeSum</title>
      <link href="/2019/12/17/P15ThreeSum/"/>
      <url>/2019/12/17/P15ThreeSum/</url>
      
        <content type="html"><![CDATA[<h1 id="P15三数之和"><a href="#P15三数之和" class="headerlink" title="P15三数之和"></a>P15三数之和</h1><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，*使得 *a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><pre><code class="java">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>Related Topics：数组   双指针</p><pre><code class="java">    /**          * 方案一：暴力法，直接三层循环          * 结果会出现重复数据          */    class Solution {        public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {                            List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();                 for (int i = 0; i &lt; nums.length - 2; i++) {                         for (int j = i + 1; j &lt; nums.length - 1; j++) {                                for (int k = j + 1; k &lt; nums.length; k++) {                                    if (nums[i] + nums[j] + nums[k] == 0) {                                         res.add(Arrays.asList(nums[i],nums[j],nums[k]));              }                                                                      }                  }            }          return res;      }}</code></pre><pre><code class="java">/**  * 方案二：  * 首先对该数组进行排序，然后进行判断：  *     当数组长度小于3，直接return;  *     当nums[i] &gt; 0,则三数之和一定大于0，因为一开始已经排序了，直接break;  *  */class Solution {        public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {                             List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();                               int len = nums.length;                if (nums == null || len &lt; 3) {                        return ans;                }                Arrays.sort(nums);//排序                for (int i = 0; i &lt; len; i++) {                        if (nums[i] &gt; 0) {                    break;                            //如果当前数字&gt;0，则三数之和一定大于0，则结束循环                         }                        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {                continue;                 //如果当前数字重复，则跳过。                                       }                        int L = i + 1;                        int R = len - 1;                        while (L &lt; R) {                                int sum = nums[i] + nums[L] + nums[R];                               if (sum == 0) {                                                                 ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                           while (L &lt; R &amp;&amp; nums[L] == nums[L+1]) {                      L++;                                    }                                   while (L &lt; R &amp;&amp; nums[R] == nums[R-1]) {                                        R--;                                    }                                     L++;                                     R--;                             }                                else if (sum &lt; 0) {                                       L++;                                }                                else if (sum &gt; 0) {                                        R--;                                }                        }                }                return ans;         }}</code></pre><pre><code class="java">/**  * 方案二的改进：（推荐）  * 也是用到了双向指针  */class Solution {        public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {                List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();                Arrays.sort(nums);//排序                for (int i = 0; i &lt; nums.length - 2; i++) {                        if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i-1])) {                                int L = i + 1, R = nums.length - 1, sum = 0 - nums[i];                              while (L &lt; R) {                                    if (nums[L] + nums[R] == sum) {                                                               ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                                         while (L &lt; R &amp;&amp; nums[L] == nums[L+1]) {                                                //去重                                               L++;                                        }                                         while (L &lt; R &amp;&amp; nums[R] == nums[R-1]) {                                                 //去重                                                 R--;                                         }                                         L++;                                         R--;                                  } else if (nums[L] + nums[R] &lt; sum) {                                           //向右移动                                            L++;                                    }else {                                            //向左移动                                           R--;                                    }                                }                        }                }                return ans;        }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P11ContainerWIthMostWater</title>
      <link href="/2019/12/17/P11ContainerWIthMostWater/"/>
      <url>/2019/12/17/P11ContainerWIthMostWater/</url>
      
        <content type="html"><![CDATA[<h1 id="P11盛水最多的容器"><a href="#P11盛水最多的容器" class="headerlink" title="P11盛水最多的容器"></a>P11盛水最多的容器</h1><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><pre><code class="java">输入: [1,8,6,2,5,4,8,3,7]输出: 49</code></pre><p>Related Topics：数组    双指针</p><pre><code class="java">    /**     * 方案一：双指针法（推荐）     * 定义i,j分别在容器两端，向中间聚集，只到i==j结束，定义最大容积为res     * 利用三元函数，当height[i]与height[j]比较，取最小值。     * 当height[i]较小时，则res = Math.max(res, (j -i) * height[i++])     * 当height[j]较小时，则res = Math.max(res, (j -i) * height[j--])     */    class Solution {    public int maxArea(int[] height) {        int j,res;        int i = 0; j = height.length - 1; res = 0;        while (i &lt; j) {            res = height[i] &lt; height[j] ? Math.max(res, (j - i) * height[i++]) : Math.max(res, (j - i) * height[j--]);        }        return res;        }    }</code></pre><pre><code class="java">/**  * 方案二：暴力法 * 定义i，j = i+1，两层循环得到容积的最大  * 问题，有好多本身冗余的值  */class Solution {        public int maxArea(int[] height) {             int res = 0;             for (int i = 0; i &lt; height.length; i++) {                     for (int j = i + 1; j &lt; height.length; j++) {                            res = Math.max(res,Math.min(height[i],height[j]) * (j - i));                             return res;                     }             }        }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1TwoSum</title>
      <link href="/2019/12/09/P1TwoSum/"/>
      <url>/2019/12/09/P1TwoSum/</url>
      
        <content type="html"><![CDATA[<h1 id="P1两数之和"><a href="#P1两数之和" class="headerlink" title="P1两数之和"></a>P1两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><pre><code class="java">给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>Related Topics：数组，哈希表</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>暴力法：遍历每一个元素，运行用两层for循环，进行判断。</p><pre><code class="java">class Solution {    public int[] twoSum(int[] nums, int target) {        for (int i = 0; i &lt; nums.length; i++) {            for (int j = i + 1; j &lt; nums.length; j++) {                if (nums[j] = target - nums[i]) {                    return new int[] {i,j};                }            }        }         throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}//总结：时间复杂度为：O（n^2）</code></pre><h2 id="方法二：推荐"><a href="#方法二：推荐" class="headerlink" title="方法二：推荐"></a>方法二：<code>推荐</code></h2><p>使用一遍哈希表</p><pre><code class="java">class Solution {        public int[] twoSum(int[] nums, int target) {            //声明一个HashMap            Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();            for (int i = 0; i &lt; nums.length; i++) {       //现将所有能够满足target - num[i],找出，然后再去之后保存的map中查询。                int complement = target - nums[i];                //找到所有满足complement且与i不冲突的                if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {                    return new int[] {i,map.get(complement)};                }                //利用map将数组元素与索引一一对应                map.put(nums[i], i);            }        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P283移动零</title>
      <link href="/2019/11/22/algorithm-learning04/"/>
      <url>/2019/11/22/algorithm-learning04/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><p>Related Topics：数组，双指针</p></li></ol><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>遍历所有数组并统计零的个数，将所有非零数往前移动，最后在数组末尾添加统计零的个数。</p><p><code>每个非零数往前移动步数就是该非零数前面零的个数。</code></p><pre><code class="java">static class Solution {        public void moveZeroes(int[] nums) {            //统计0的个数            int count = 0;            for (int i = 0; i &lt; nums.length; i++) {                if (nums[i] == 0) {                    count++;                }else {                    //非零数往前移动步数就是该非零数前面零的个数                    num[i - count] = nums[i];                }            }            //在数组末尾添加零            for (int i = nums.length - count; i &lt; nums.length; i++) {                nums[i] = 0;            }        }}</code></pre><h2 id="对方法一的改进："><a href="#对方法一的改进：" class="headerlink" title="对方法一的改进："></a>对方法一的改进：</h2><h4 id="1-通过交换改进在尾部添加0"><a href="#1-通过交换改进在尾部添加0" class="headerlink" title="1.通过交换改进在尾部添加0"></a>1.通过交换改进在尾部添加0</h4><h4 id="2-通过判断count是否-gt-0-避免不必要交换"><a href="#2-通过判断count是否-gt-0-避免不必要交换" class="headerlink" title="2.通过判断count是否 &gt; 0 避免不必要交换"></a>2.通过判断count是否 &gt; 0 避免不必要交换</h4><pre><code class="java">static class Solution {        public void moveZeroes(int[] nums) {            //统计0的个数            int count = 0;            for (int i = 0; i &lt; nums.length; i++) {                if (nums[i] == 0) {                    count++;                }else if (count &gt; 0) {                }            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02训练环境设置，编码技巧，Code Style及时间空间复杂度</title>
      <link href="/2019/11/21/algorithm-learning02/"/>
      <url>/2019/11/21/algorithm-learning02/</url>
      
        <content type="html"><![CDATA[<h1 id="训练环境的设置，编码技巧和Code-Style"><a href="#训练环境的设置，编码技巧和Code-Style" class="headerlink" title="训练环境的设置，编码技巧和Code Style"></a>训练环境的设置，编码技巧和Code Style</h1><h2 id="电脑配置"><a href="#电脑配置" class="headerlink" title="电脑配置"></a>电脑配置</h2><ul><li>搜索引擎默认Google</li><li>Terminal<ul><li>Mac:iTerm2 +zsh</li><li>Windows:Microsoft new terminal</li></ul></li><li>LeetCode plugin (vscode &amp; IntelliJ)</li><li><a href="http://vscodethemes.com/" target="_blank" rel="noopener">http://vscodethemes.com/</a></li><li>骚操作<ul><li><a href="https://juejin.im/entry/587e0f2f570c352201113e14" target="_blank" rel="noopener">https://juejin.im/entry/587e0f2f570c352201113e14</a></li><li><a href="https://juejin.im/post/5ce1365151882525ff28ed47" target="_blank" rel="noopener">https://juejin.im/post/5ce1365151882525ff28ed47</a></li></ul></li></ul><h2 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h2><ul><li>Google Code Style</li></ul><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><ul><li>leetcode-cn.com(国内版)和题</li><li>leetcode.com（国外版）和Discuss border</li></ul><h2 id="指法和小操作"><a href="#指法和小操作" class="headerlink" title="指法和小操作"></a>指法和小操作</h2><ul><li>home , end (行头，行尾)</li><li>word单词，选单词，选整行</li><li>IDE的自动补全</li><li>Top tips for <IDE-name></li></ul><p><code>养成使用快捷键的习惯，提高编码效率</code></p><h2 id="自顶向下的编程方式"><a href="#自顶向下的编程方式" class="headerlink" title="自顶向下的编程方式"></a>自顶向下的编程方式</h2><p><a href="https://markhneedham.com/blog/2008/09/15/clean-code-book-review/" target="_blank" rel="noopener">https://markhneedham.com/blog/2008/09/15/clean-code-book-review/</a></p><hr><h1 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h1><h2 id="Big-O-notation"><a href="#Big-O-notation" class="headerlink" title="Big O notation"></a>Big O notation</h2><ul><li>O（1）:常数复杂度</li><li>O（log n）:对数复杂度</li><li>O（n）：线性时间复杂度</li><li>O（n^2）:N 平方</li><li>O（n^3）:N 立方</li><li>O（2^n）:指数O（n!）:阶乘</li></ul><p><code>注意：只看最高复杂度的运算。</code></p><pre><code class="java">O(1):    int n = 100;    System.out.println(&quot;hello &quot; + n);O(1):        int n = 1000;    System.out.println(&quot;hello &quot; + n);    System.out.println(&quot;hi &quot; + n);    System.out.println(&quot;helo &quot; + n);O(N):    for(int i = 1; i&lt;= n; i++) {        System.out.println(&quot;hello &quot; + i);    }O(N^2):    for (int i = 1; i&lt;=n; i++) {        for (int j = 1; j&lt;=n; j++) {            System.out.println(&quot;hello &quot; + i + j);        }    }O(log(n)):    for (int i = 1; i &lt; n; i = i * 2) {        System.out.println(&quot;hello &quot; + i);    }O(k^n):    int fib(int n) {        if(n &lt;=2 ) return n;        return fib(n - 1) + fib(n - 2);     }</code></pre><h2 id="Master-Theorem-主定理"><a href="#Master-Theorem-主定理" class="headerlink" title="Master Theorem(主定理)"></a>Master Theorem(主定理)</h2><img src="https://s2.ax1x.com/2019/11/21/MoMpuR.png" alt="MoMpuR.png" border="0" /><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li><p>二叉树遍历-前序，中序，后序：时间复杂度是多少？</p><p>O（n）,n 为节点总数</p></li><li><p>图的遍历：时间复杂度是多少？</p><p>O（n）,n 为节点总数</p></li><li><p>搜索算法：DFS深度优先算法、BFS广度优先算法时间复杂度是多少？</p><p>O（n）,n 为节点总数</p></li><li><p>二分查找：时间复杂度是多少？</p><p>O（log n)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01数据结构与算法概览</title>
      <link href="/2019/11/21/algorithm-learning01/"/>
      <url>/2019/11/21/algorithm-learning01/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐书籍：《异类：不一样的成功启示》"><a href="#推荐书籍：《异类：不一样的成功启示》" class="headerlink" title="推荐书籍：《异类：不一样的成功启示》"></a>推荐书籍：<code>《异类：不一样的成功启示》</code></h2><p>精通一个领域：</p><ul><li>切碎知识点</li><li>刻意练习（五毒神掌，练习弱项）</li><li>反馈<ul><li>主动反馈</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>一维：<ul><li>基础：数组array (String),链表 linked list</li><li>高级：栈 stack, 队列 queue, 双端队列 deque, 集合 set , 映射 map(hash or map)</li></ul></li><li>二维：<ul><li>基础：数tree  ,图 graph</li><li>高级：二叉搜索树 binary search tree(red-black tree红黑树,AVL)，堆 heep， 并查集 disjoint set,字典树 Trie</li></ul></li><li>特殊：<ul><li>位运算 Bitwise, 布隆过滤器 BloomFilter</li><li>LRU Cache缓存</li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>if-else,switch –&gt;branch</li><li>for,while loop—&gt;iteration</li><li>递归 Recursion(Divide &amp; Conquer, Backtrace)</li><li>搜索 Search:  深度优先搜索(Depth first search) ,广度优先搜索（Breadth first search）</li><li>动态规划 Dynamic Programming</li><li>二分查找Binary Search</li><li>贪心算法 Greedy</li><li>数学 Math ,几何 Geometry </li></ul><p>注意：<code>刻意练习（五毒神掌）</code></p><h2 id="切题四件套"><a href="#切题四件套" class="headerlink" title="切题四件套"></a>切题四件套</h2><ul><li>审题清晰</li><li>想出可能的解法们<ul><li>比较，加强</li></ul></li><li>多写</li><li>测试</li></ul><h2 id="五毒神掌"><a href="#五毒神掌" class="headerlink" title="五毒神掌"></a>五毒神掌</h2><h3 id="刷题第一遍"><a href="#刷题第一遍" class="headerlink" title="刷题第一遍"></a>刷题第一遍</h3><ul><li>5分钟：读题 + 思考</li><li>直接看解法：注意！多解法，比较解法优劣。</li><li><code>背诵，默写</code>解法。</li></ul><h3 id="刷题第二遍"><a href="#刷题第二遍" class="headerlink" title="刷题第二遍"></a>刷题第二遍</h3><ul><li>马上自己写—&gt;LeetCode提交</li><li>多种解法比较，体会–&gt;优化!</li></ul><h3 id="刷题第三遍"><a href="#刷题第三遍" class="headerlink" title="刷题第三遍"></a>刷题第三遍</h3><ul><li>一天之后，重复做原题。</li><li>不同解法的熟练程度—&gt;专项练习</li></ul><h3 id="刷题第四遍"><a href="#刷题第四遍" class="headerlink" title="刷题第四遍"></a>刷题第四遍</h3><ul><li>一个月之后，重复做原题。</li></ul><h3 id="刷题第五遍"><a href="#刷题第五遍" class="headerlink" title="刷题第五遍"></a>刷题第五遍</h3><ul><li>面试前一周恢复性训练</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA开发自学之路</title>
      <link href="/2019/11/18/introduction-to-java/"/>
      <url>/2019/11/18/introduction-to-java/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><code>基础知识</code></h2><ul><li>编程语言：Java Python C</li><li>基本算法</li><li>基本网络知识：TCP/IP HTTP/HTTPS</li><li>基本的设计模式</li></ul><hr><h2 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a><code>工具方面</code></h2><ul><li>操作系统：Linux (Centos\Deepin)</li><li>代码管理：SVN  / Git</li><li>持续集成（CI/CD）：Jenkins</li><li>Java的项目管理工具：Maven / Gradle</li></ul><hr><h2 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a><code>框架方面</code></h2><h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a><code>应用框架</code></h3><ul><li>SSH：<del>spring + structs + hibernate</del> (旧)</li><li>SSM：spring + spring mvc + mybatis</li><li>Spring Boot</li></ul><h3 id="各种中间件"><a href="#各种中间件" class="headerlink" title="各种中间件"></a><code>各种中间件</code></h3><ul><li>MQ 消息队列</li><li>RPC 通信框架  gRPC  thrift  dubbo  springCloud</li><li>elasticsearch 数据库    搜索引擎</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><code>数据库</code></h3><ul><li>SQL：MySQL / Postgre SQL</li><li>NoSQL：Redis Memcached mongodb elasticsearch</li></ul><hr><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a><code>架构方面</code></h2><h3 id="分布式-微服务架构"><a href="#分布式-微服务架构" class="headerlink" title="分布式 / 微服务架构"></a>分布式 / 微服务架构</h3><ul><li>spring cloud</li><li>dubbo</li><li>rpc通信</li></ul><h3 id="虚拟化-容器化"><a href="#虚拟化-容器化" class="headerlink" title="虚拟化 / 容器化"></a><code>虚拟化 / 容器化</code></h3><ul><li>Docker 容器化</li><li>K8s kubernetes</li></ul><hr><h2 id="关注源码-性能"><a href="#关注源码-性能" class="headerlink" title="关注源码 / 性能"></a>关注源码 / 性能</h2><ul><li>JDK源码以及部分设计思想</li><li>Spring 源码</li><li>JVM 细节与排错，调优</li><li>高并发 / 高可用</li><li>UGC应用</li><li>爬虫，电商，社交项目开发</li></ul><h3 id="推荐书籍："><a href="#推荐书籍：" class="headerlink" title="推荐书籍："></a><code>推荐书籍</code>：</h3><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><ul><li>Java编程思想</li><li>Java并发编程</li><li>深入理解Java虚拟机</li><li>函数式编程思维</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>TCP/IP 详解</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>Spring 技术内幕</li></ul><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><ul><li>Redis 快速入门</li><li>Elasticsearch 服务器开发</li></ul><p>来源大佬：程序羊 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">CodeSheep</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sso-learning</title>
      <link href="/2019/11/16/sso-learning/"/>
      <url>/2019/11/16/sso-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><code>背景</code></h2><p>​       在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 </p><p>什么是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>?</p><p>单点登录英文全称Single Sign On，简称就是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong> </p><div align="center"><img src="https://yqfile.alicdn.com/721f02ebe06639e6232b59535d6423db75086693.png"></div><p> 如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的定义。 </p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a><code>技术实现</code></h2><p>在说单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的技术实现之前，我们先说一说普通的登录认证机制。</p><div align="center"><img src="https://yqfile.alicdn.com/555f1a6856468578020ea0486f563b3633813050.png"></div><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a><code>同域下的单点登录</code></h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li></ul><div align="center"><img src="https://yqfile.alicdn.com/4e31c204eea22ee07154df928a5ff5350da03d7a.png"></div><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p><h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a><code>不同域下的单点登录</code></h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。</p><div align="center"><img src="https://yqfile.alicdn.com/dcb743204f8a201be53df5338fc34affe5fa1059.png"/></div><p>上图是CAS官网上的标准流程，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p><p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h2><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li><li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li><li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li></ul><p>转载来自：<a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">云栖社区(小忽悠)</a></p>]]></content>
      
      
      <categories>
          
          <category> 积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门实践</title>
      <link href="/2019/11/15/docker-introductory-practice/"/>
      <url>/2019/11/15/docker-introductory-practice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）</p><p>虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式） </p><p>本机：192.168.0.5 1. Docker安装与启动</p></blockquote><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. <code>准备工作</code></h1><h2 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1 安装Docker"></a>1.1 安装Docker</h2><p>​    (1)yum包更新到最新</p><p>  （2）安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper屈都依赖的</p><blockquote><p>​       </p><pre><code> sudo yum install -y  yum-utils devicemapper-persistent-data lvm2</code></pre></blockquote><p>​    (3) 设置yum源为阿里云</p><blockquote><p>​        <code>sudo yum-coonfig-manager --add-repo</code>        </p><p>[]: <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></blockquote><p>​    (4) 安装docker</p><blockquote><p>​        <code>sudo yum install docker-ce</code></p></blockquote><p>​    (5) 查看版本</p><blockquote><p>​        <code>docker -v</code></p></blockquote><h2 id="1-2-设置ustc的镜像"><a href="#1-2-设置ustc的镜像" class="headerlink" title="1.2 设置ustc的镜像"></a>1.2 设置ustc的镜像</h2><p>​    (1) 编辑该文件</p><blockquote><p>​        vi /etc/docker/daemon.json</p></blockquote><p>​    (2) 该文件中输入如下内容：</p><blockquote><p>​       </p><pre><code> {​        “registry-mirrors”:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]​        }</code></pre></blockquote><h2 id="1-3-Docker的启动与停止"><a href="#1-3-Docker的启动与停止" class="headerlink" title="1.3 Docker的启动与停止"></a>1.3 Docker的启动与停止</h2><p>​      <strong>systemctl</strong> 命令是系统服务管理器指令</p><blockquote><p>​        启动docker</p><p>​            systemctl start docker</p><p>​        停止docker</p><p>​            systemctl stop docker</p><p>​        重启docker</p><p>​            systemctl restart docker</p><p>​        查看docker状态</p><p>​            systemctl status docker</p><p>​        开机启动</p><p>​            systemctl enable docker</p><p>​        查看docker概要信息</p><p>​            docker  info</p></blockquote><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. <code>常用命令</code></h1><h2 id="2-1-镜像相关命令"><a href="#2-1-镜像相关命令" class="headerlink" title="2.1 镜像相关命令"></a>2.1 镜像相关命令</h2><h3 id="2-1-1-查看镜像"><a href="#2-1-1-查看镜像" class="headerlink" title="2.1.1 查看镜像"></a>2.1.1 查看镜像</h3><blockquote><p>​        docker images</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f93cb5e0123a841f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-2-搜索镜像"><a href="#2-1-2-搜索镜像" class="headerlink" title="2.1.2 搜索镜像"></a>2.1.2 搜索镜像</h3><blockquote><p>​        docker search 镜像名称</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-8b9d9f04b51c22a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-3-拉取镜像"><a href="#2-1-3-拉取镜像" class="headerlink" title="2.1.3 拉取镜像"></a>2.1.3 拉取镜像</h3><blockquote><p>​        docker pull  镜像名称</p></blockquote><p>​        例如  docker  pull  centos:7</p><h3 id="2-1-4-删除镜像"><a href="#2-1-4-删除镜像" class="headerlink" title="2.1.4 删除镜像"></a>2.1.4 删除镜像</h3><blockquote><p>​        docker  rmi  镜像ID</p></blockquote><p>​        删除所有镜像：docker rmi  ‘docker  images  -q’</p><h2 id="2-2-容器相关命令"><a href="#2-2-容器相关命令" class="headerlink" title="2.2 容器相关命令"></a>2.2 容器相关命令</h2><h2 id="2-2-1-查看容器"><a href="#2-2-1-查看容器" class="headerlink" title="2.2.1 查看容器"></a>2.2.1 查看容器</h2><blockquote><p>​        查看正在运行容器：  docker  ps</p><p>​        查看所有容器： docker  ps  -a</p><p>​        查看最后一次运行容器： docker ps -1</p><p>​        查看停止容器： docker ps -f status=exited</p></blockquote><h3 id="2-2-2-创建与启动容器"><a href="#2-2-2-创建与启动容器" class="headerlink" title="2.2.2 创建与启动容器"></a>2.2.2 创建与启动容器</h3><blockquote><p>​        创建容器命令：docker run</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f47a717be5859766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​        (1) 交互式方式创建容器</p><blockquote><p>​            docker  run  -it  –name=容器名称  镜像名称：标签  /bin/bas</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08c91e9104339b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​              此时，创建完毕后直接进入。</p><p>​              进入容器后exit退出，容器状态自动变为exited.</p><p>​        (2) 守护式方式创建容器</p><blockquote><p>​                docker  run  -di  –name=容器名称  镜像名称：标签</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31bd00e3d1c6470b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                此时，创建完毕后未进入容器</p><p>​                登陆守护方式容器：docker exec -it 容器名称（或者ID） /bin/bash</p><p>​                注意：本次创建容器时，即使上面交互式方式创建的容器mycentos已经关闭，此时仍然不能本次容器也为mycentos!!!</p><h3 id="2-2-3-停止与启动容器"><a href="#2-2-3-停止与启动容器" class="headerlink" title="2.2.3 停止与启动容器"></a>2.2.3 停止与启动容器</h3><blockquote><p>​        停止容器：docker  stop  容器名称（或者ID）</p><p>​        启动容器：docker  start  容器名称（或者ID）</p></blockquote><h3 id="2-2-4-文件拷贝"><a href="#2-2-4-文件拷贝" class="headerlink" title="2.2.4 文件拷贝"></a>2.2.4 文件拷贝</h3><blockquote><p>将文件拷贝到容器内：docker  cp  需要拷贝文件或目录  容器名称:容器目录</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1c82c75233452cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>将文件拷贝出容器外：docker  cp  容器名称:容器目录  需要拷贝文件或目录</p></blockquote><h3 id="2-2-5-目录挂载"><a href="#2-2-5-目录挂载" class="headerlink" title="2.2.5 目录挂载"></a>2.2.5 目录挂载</h3><p><img src="https://upload-images.jianshu.io/upload_images/17169295-be3d71e849f42d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-6-查看容器IP地址"><a href="#2-2-6-查看容器IP地址" class="headerlink" title="2.2.6 查看容器IP地址"></a>2.2.6 查看容器IP地址</h3><blockquote><p>​            docker  inspect 容器名称（或者ID）</p></blockquote><p>直接查找到IP地址方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08d215cdd9404acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-7-删除容器"><a href="#2-2-7-删除容器" class="headerlink" title="2.2.7 删除容器"></a>2.2.7 删除容器</h3><blockquote><p>​        docker  rm  容器名称（或者ID）</p></blockquote><p>​        <strong>注意：1. 与删除镜像区别（删除镜像：docker  rmi  镜像ID）</strong></p><p>​                  <strong>2. 在删除镜像时，要把对应全部创建的容器删除才可以删除镜像！</strong></p><h1 id="3-应用部署"><a href="#3-应用部署" class="headerlink" title="3. 应用部署"></a>3. <code>应用部署</code></h1><h2 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h2><p>​    （1） 拉取mysql镜像</p><blockquote><p>​                docker  pull centos/mysql-57-centos7</p></blockquote><p>​    （2） 创建容器</p><blockquote><p>​                docker  run  -di  –name=tensquare_mysql  -p  33306:3306  -e  MYSQL_PASSWORD=123456  mysql</p></blockquote><p>​                -p  代表端口映射，格式为  宿主机映射端口：容器运行端口</p><p>​                -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的密码</p><p>​    （3） 进入mysql容器</p><blockquote><p>​                  docker  exec  -it  tensquare_mysql  /bin/bash</p></blockquote><p>​    （4） 登陆mysql</p><blockquote><p>​                mysql  -u  root  -p</p></blockquote><p>​    （5） 远程登陆mysql</p><p>​                连接宿主机IP并指定端口为33306，这样就可以操作容器的3306端口。</p><h2 id="3-2-tomcat部署"><a href="#3-2-tomcat部署" class="headerlink" title="3.2 tomcat部署"></a>3.2 tomcat部署</h2><p>​    （1） 拉取镜像</p><blockquote><p>​                    docker  pull  tomcat:7-jre7</p></blockquote><p>​        (2) 创建容器</p><p>​                    创建容器  -p 表示地址映射</p><blockquote><p>​                    docker  run  -di  –name=mytomcat  -p  9000:8080  -v /usr/local/webapps:/usr/local/tomcat/webapps  tomcat:7-jre7</p></blockquote><p>​      （3） 进入mysql容器</p><blockquote><p>​                    docker  exec  -it  mytomcat  /bin/bash</p></blockquote><p>​      （4） 远程访问：192.168.0.19:9000/index.jsp</p><h2 id="3-3-Nginx部署"><a href="#3-3-Nginx部署" class="headerlink" title="3.3 Nginx部署"></a>3.3 Nginx部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull  nginx</p></blockquote><p>​        (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=mynginx  -p  80:80  nginx</p></blockquote><h2 id="3-4-Redis部署"><a href="#3-4-Redis部署" class="headerlink" title="3.4 Redis部署"></a>3.4 Redis部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull redis</p></blockquote><p>​          (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=myredis  -p  6379:6379  redis</p></blockquote><h1 id="4-迁移与备份"><a href="#4-迁移与备份" class="headerlink" title="4. 迁移与备份"></a>4. <code>迁移与备份</code></h1><h2 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1  容器保存为镜像"></a>4.1  容器保存为镜像</h2><blockquote><p>​            docker  commit  mynginx  mynginx_i</p></blockquote><h2 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2  镜像备份"></a>4.2  镜像备份</h2><blockquote><p>​            docker  save  -o  mynginx.tar  mynginx_i</p></blockquote><h3 id="4-3-镜像恢复与迁移"><a href="#4-3-镜像恢复与迁移" class="headerlink" title="4.3  镜像恢复与迁移"></a>4.3  镜像恢复与迁移</h3><blockquote><p>​            docker  load  -i  mynginx.tar</p></blockquote><p>​            -i  输入的文件</p><blockquote><p>​            docker  images  可看到镜像已恢复</p></blockquote><h1 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. <code>Dockerfile</code></h1><h2 id="5-1-什么是Dockerfile"><a href="#5-1-什么是Dockerfile" class="headerlink" title="5.1 什么是Dockerfile"></a>5.1 什么是Dockerfile</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-a222a077dc4601f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-6bf066c4b2fcff21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-3-使用脚本创建镜像"><a href="#5-3-使用脚本创建镜像" class="headerlink" title="5.3 使用脚本创建镜像"></a>5.3 使用脚本创建镜像</h2><p>​        （1）创建目录</p><blockquote><p>​                mkdir -p /usr/local/dockerjdk8</p></blockquote><p>​        （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器中/usr/local/dockerjdk8目录</p><p>​        （3）在dockerjdk8目录下创建文件Dockerfile    vi  Dockerfile</p><blockquote><p>​                    #依赖镜像名称和ID</p><p>​                    FROM centos7</p><p>​                    #指定镜像创建者</p><p>​                    MAINTAINER FENCO</p><p>​                    #切换工作目录</p><p>​                    WORKDIR  /usr</p><p>​                    RUN  mkdir  /usr/local/java</p><p>​                    #ADD  是相对路径jar,把java添加到容器</p><p>​                    ADD  jdk-8u171-linux-x64.tar.gz  /usr/local/java/</p></blockquote><blockquote><p>​                    #配置java环境变量</p><p>​                    ENV  JAVA_HOME   /usr/local/java/jdk1.8.0_171</p><p>​                    ENV  JRE_HOME   $JAVA_HOME/jre</p><p>​                    ENV  CLASSPATH   $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</p><p>​                    ENV  PATH  $JAVA_HOME/bin:$PATH</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-077f15b821721ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                            <strong>注意：由于创建jdk1.8镜像用到了docker.io/centos镜像，所以必须保证本地有该镜像。</strong></p><p>​             (4) 执行命令构建镜像</p><blockquote><p>​                       在dockerjdk8目录下执行：    docker   build  -t=’jdk1.8’  .           最后面的点，表示该根目录</p></blockquote><p>​            (5) 查看镜像是否建立完成</p><blockquote><p>​                        docker  images</p></blockquote><h1 id="6-Docker私有仓库"><a href="#6-Docker私有仓库" class="headerlink" title="6. Docker私有仓库"></a>6. <code>Docker私有仓库</code></h1><h2 id="6-1-私有仓库的搭建及配置"><a href="#6-1-私有仓库的搭建及配置" class="headerlink" title="6.1 私有仓库的搭建及配置"></a>6.1 私有仓库的搭建及配置</h2><p>​    （1） 拉取私有仓库镜像</p><blockquote><p>​        docker pull registry</p></blockquote><p>​      (2)  启动私有仓库容器</p><blockquote><p>​            docker  run  -di  –name=registry  -p  5000:5000  registry</p></blockquote><p>​     (3) 用浏览器访问：<a href="http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。" target="_blank" rel="noopener">http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。</a></p><p>  （4）修改daemon.json</p><blockquote><p>​            vi  /etc/docker/daemon.json</p><p>​            添加以下内容并保存退出。</p><p>​            {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>  （5） 重启docker服务</p><blockquote><p>​            systemctl restart  docker</p></blockquote><h2 id="6-2-镜像的上传及下载到私有仓库"><a href="#6-2-镜像的上传及下载到私有仓库" class="headerlink" title="6.2 镜像的上传及下载到私有仓库"></a>6.2 镜像的上传及下载到私有仓库</h2><h3 id="6-2-1镜像的上传"><a href="#6-2-1镜像的上传" class="headerlink" title="6.2.1镜像的上传"></a>6.2.1镜像的上传</h3><p>​    （1） 标记次镜像为私有仓库的镜像</p><blockquote><p>​                docker tag jdk1.8 192.168.0.19:5000/jdk1.8</p></blockquote><p>​      (2) 上传标记镜像</p><blockquote><p>​                首先，上一步重启了docker服务，所以里面的registry容器也需要启动下。</p><p>​                然后执行上传：docker  push  192.168.0.19:5000/jdk1.8</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4e37943897353c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="6-2-2-镜像的下载"><a href="#6-2-2-镜像的下载" class="headerlink" title="6.2.2 镜像的下载"></a>6.2.2 镜像的下载</h3><p><strong>在另外一台虚拟机中安装docker（192.168.0.21）</strong></p><p>​    （1）修改daemon.json</p><blockquote><p>​                vi  /etc/docker/daemon.json</p><p>​                添加以下内容并保存退出。</p><p>​                {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>​    （2） 重启docker服务</p><blockquote><p>​                systemctl restart  docker</p></blockquote><p>​     (3) 下载标记镜像</p><blockquote><p>​                然后执行下载：docker  pull  192.168.0.19:5000/jdk1.8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes_learningng_01</title>
      <link href="/2019/11/13/kubernetes-learningng-01/"/>
      <url>/2019/11/13/kubernetes-learningng-01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kubernetes的介绍"><a href="#1-Kubernetes的介绍" class="headerlink" title="1.Kubernetes的介绍"></a>1.Kubernetes的介绍</h2><h3 id="1-1Kubernetes与Docker"><a href="#1-1Kubernetes与Docker" class="headerlink" title="1.1Kubernetes与Docker"></a>1.1Kubernetes与Docker</h3><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C1.png" alt=""></p><p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC(Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源)有关的容器技术。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C2.png" alt=""></p><p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C3.png" alt=""></p><p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p><p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C4.png" alt=""></p><p>Open Source，开源</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-03f79be8f1c3a859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Solomon Hykes</p><p>不开则已，一开惊人。</p><p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p><p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p><p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-65f6a350d2889e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-dd4eeed33ca1d759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。</p><p>而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化。</strong></p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4790d914c6bbdd53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-79394519ff0633de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>我们具体来看看Docker。Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“<strong>一次构建，到处运行（Build once，run anywhere）</strong>”。</p><p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p><p>想要搞懂Docker，其实看它的两句口号就行。</p><p>第一句，是“<strong>Build, Ship and Run</strong>”。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-ada467dd294a3fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>也就是，“搭建、发送、运行”，三板斧。</p><p>举个例子：</p><p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-853f90a47874564c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p><p>但是，跑来一个老巫婆，教会我一种魔法。</p><p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-753393ea28196c31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5c237217f6bd517d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>怎么样？是不是很神奇？</p><p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p><p>Docker技术的三大核心概念，分别是：</p><p><strong>镜像（Image）</strong></p><p><strong>容器（Container）</strong></p><p><strong>仓库（Repository）</strong></p><p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p><p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p><p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p><p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p><p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9ca3a319ce4d91ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>于是乎，就变成了一个大的公共仓库。</p><p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p><p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p><p>所以，Docker Registry服务对镜像的管理是非常严格的。</p><p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>好了，说完了Docker，我们再把目光转向K8S。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p><p>就在这个时候，K8S出现了。</p><p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f0aa142c93e879de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p><p>这个集群主要包括两个部分：</p><p><strong>一个Master节点（主节点）</strong></p><p><strong>一群Node节点（计算节点）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-cca00815aa29d21c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p><p>深入来看这两种节点。</p><p>首先是<strong>Master节点。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1bc2e7499cbe5dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p><p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p><p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p><p>Controller manager负责管理控制器，相当于“大总管”。</p><p>然后是<strong>Node节点</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3538dfa59c20c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p><p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p><p>Docker，不用说了，创建容器的。</p><p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p><p>Kube-proxy，主要负责为Pod对象提供代理。</p><p>Fluentd，主要负责日志收集、存储与查询。</p><p><strong>另外一种通俗的解释：（可以先往下学习，等学的差不多了，再来看更能理解）</strong></p><p>18张儿童插画让你秒懂Kubernetes</p><p>很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0b0aebb675f9c57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc457f68dfddb846.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。</p><p>每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-01e1f91dc2c50cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0c4f7abbcfb19b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>(Docker)容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。</p><p>对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc6d941e7e393395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。</p><p>就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。</p><p>“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31cf971fbdeb8ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2fa9619ea6e41154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“我是 Phippy。”小应用程序说。</p><p>“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-57696b2530f1b594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9a5206fa58576b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-d816b7b515e39c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。</p><p>但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。</p><p>Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2d75cd71125c0e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢?”</p><p>“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-18849e1d5226165e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。</p><p>通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5a3010b48e9fba80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。</p><p>Kube 船长慈祥地笑了笑：“我正好有一样东西。”</p><p>他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你!”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-e1eab190db313f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>服务告知 Kubernetes 环境的其余部分(包括其他 Pod 和 Replication Controller)你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。</p><p>其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3a92c6383ee31771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了***的朋友。</p><p>有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。</p><p>“你为什么这么伤心呢?”Goldie 问道。</p><p>“我喜欢这个礼物，但我没有地方可以放它!”Phippy 抽噎道。</p><p>但 Goldie 知道该怎么做。“为什么不把它放入卷中呢?”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1cc777d3edf587a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。</p><p>Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴(Goldie 和每个克隆人都同样令人愉悦)。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。</p><p>“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-30ee26dd6873f48d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。</p><p>Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。</p><p>所以 Phippy 从此过上了幸福的生活。</p><p>转自：<a href="https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）" target="_blank" rel="noopener">https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
