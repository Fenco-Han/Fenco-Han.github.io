<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA开发自学之路</title>
      <link href="/2019/11/18/introduction-to-java/"/>
      <url>/2019/11/18/introduction-to-java/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><code>基础知识</code></h2><ul><li>编程语言：Java Python C</li><li>基本算法</li><li>基本网络知识：TCP/IP HTTP/HTTPS</li><li>基本的设计模式</li></ul><hr><h2 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a><code>工具方面</code></h2><ul><li>操作系统：Linux (Centos\Deepin)</li><li>代码管理：SVN  / Git</li><li>持续集成（CI/CD）：Jenkins</li><li>Java的项目管理工具：Maven / Gradle</li></ul><hr><h2 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a><code>框架方面</code></h2><h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a><code>应用框架</code></h3><ul><li>SSH：<del>spring + structs + hibernate</del> (旧)</li><li>SSM：spring + spring mvc + mybatis</li><li>Spring Boot</li></ul><h3 id="各种中间件"><a href="#各种中间件" class="headerlink" title="各种中间件"></a><code>各种中间件</code></h3><ul><li>MQ 消息队列</li><li>RPC 通信框架  gRPC  thrift  dubbo  springCloud</li><li>elasticsearch 数据库    搜索引擎</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><code>数据库</code></h3><ul><li>SQL：MySQL / Postgre SQL</li><li>NoSQL：Redis Memcached mongodb elasticsearch</li></ul><hr><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a><code>架构方面</code></h2><h3 id="分布式-微服务架构"><a href="#分布式-微服务架构" class="headerlink" title="分布式 / 微服务架构"></a>分布式 / 微服务架构</h3><ul><li>spring cloud</li><li>dubbo</li><li>rpc通信</li></ul><h3 id="虚拟化-容器化"><a href="#虚拟化-容器化" class="headerlink" title="虚拟化 / 容器化"></a><code>虚拟化 / 容器化</code></h3><ul><li>Docker 容器化</li><li>K8s kubernetes</li></ul><hr><h2 id="关注源码-性能"><a href="#关注源码-性能" class="headerlink" title="关注源码 / 性能"></a>关注源码 / 性能</h2><ul><li>JDK源码以及部分设计思想</li><li>Spring 源码</li><li>JVM 细节与排错，调优</li><li>高并发 / 高可用</li><li>UGC应用</li><li>爬虫，电商，社交项目开发</li></ul><p>来源大佬：程序羊 <a href="https://www.codesheep.cn/" target="_blank" rel="noopener">CodeSheep</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 网络 </category>
          
          <category> 算法 </category>
          
          <category> 工具 </category>
          
          <category> 运维 </category>
          
          <category> 框架 </category>
          
          <category> 数据库 </category>
          
          <category> 架构 </category>
          
          <category> 源码 </category>
          
          <category> 积累 </category>
          
          <category> 思想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sso-learning</title>
      <link href="/2019/11/16/sso-learning/"/>
      <url>/2019/11/16/sso-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><code>背景</code></h2><p>​       在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。 </p><p>什么是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>?</p><p>单点登录英文全称Single Sign On，简称就是<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong> </p><div align="center"><img src="https://yqfile.alicdn.com/721f02ebe06639e6232b59535d6423db75086693.png"></div><p> 如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的定义。 </p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a><code>技术实现</code></h2><p>在说单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>）的技术实现之前，我们先说一说普通的登录认证机制。</p><div align="center"><img src="https://yqfile.alicdn.com/555f1a6856468578020ea0486f563b3633813050.png"></div><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a><code>同域下的单点登录</code></h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（<a href="https://baike.baidu.com/item/SSO/3451380?fr=aladdin" target="_blank" rel="noopener">SSO</a>），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</li></ul><div align="center"><img src="https://yqfile.alicdn.com/4e31c204eea22ee07154df928a5ff5350da03d7a.png"></div><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，<strong>但这还不是真正的单点登录。</strong></p><h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a><code>不同域下的单点登录</code></h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。</p><div align="center"><img src="https://yqfile.alicdn.com/dcb743204f8a201be53df5338fc34affe5fa1059.png"/></div><p>上图是CAS官网上的标准流程，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了，不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p><p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h2><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li><li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li><li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li></ul><p>转载来自：<a href="https://yq.aliyun.com/articles/636281" target="_blank" rel="noopener">云栖社区(小忽悠)</a></p>]]></content>
      
      
      <categories>
          
          <category> 积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes_learningng_01</title>
      <link href="/2019/11/13/kubernetes-learningng-01/"/>
      <url>/2019/11/13/kubernetes-learningng-01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kubernetes的介绍"><a href="#1-Kubernetes的介绍" class="headerlink" title="1.Kubernetes的介绍"></a>1.Kubernetes的介绍</h2><h3 id="1-1Kubernetes与Docker"><a href="#1-1Kubernetes与Docker" class="headerlink" title="1.1Kubernetes与Docker"></a>1.1Kubernetes与Docker</h3><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C1.png" alt=""></p><p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC(Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源)有关的容器技术。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C2.png" alt=""></p><p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C3.png" alt=""></p><p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p><p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C4.png" alt=""></p><p>Open Source，开源</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-03f79be8f1c3a859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Solomon Hykes</p><p>不开则已，一开惊人。</p><p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p><p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p><p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-65f6a350d2889e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-dd4eeed33ca1d759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。</p><p>而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化。</strong></p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4790d914c6bbdd53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-79394519ff0633de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>我们具体来看看Docker。Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“<strong>一次构建，到处运行（Build once，run anywhere）</strong>”。</p><p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p><p>想要搞懂Docker，其实看它的两句口号就行。</p><p>第一句，是“<strong>Build, Ship and Run</strong>”。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-ada467dd294a3fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>也就是，“搭建、发送、运行”，三板斧。</p><p>举个例子：</p><p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-853f90a47874564c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p><p>但是，跑来一个老巫婆，教会我一种魔法。</p><p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-753393ea28196c31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5c237217f6bd517d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>怎么样？是不是很神奇？</p><p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p><p>Docker技术的三大核心概念，分别是：</p><p><strong>镜像（Image）</strong></p><p><strong>容器（Container）</strong></p><p><strong>仓库（Repository）</strong></p><p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p><p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p><p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p><p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p><p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9ca3a319ce4d91ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>于是乎，就变成了一个大的公共仓库。</p><p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p><p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p><p>所以，Docker Registry服务对镜像的管理是非常严格的。</p><p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>好了，说完了Docker，我们再把目光转向K8S。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p><p>就在这个时候，K8S出现了。</p><p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f0aa142c93e879de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p><p>这个集群主要包括两个部分：</p><p><strong>一个Master节点（主节点）</strong></p><p><strong>一群Node节点（计算节点）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-cca00815aa29d21c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p><p>深入来看这两种节点。</p><p>首先是<strong>Master节点。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1bc2e7499cbe5dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p><p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p><p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p><p>Controller manager负责管理控制器，相当于“大总管”。</p><p>然后是<strong>Node节点</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3538dfa59c20c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p><p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p><p>Docker，不用说了，创建容器的。</p><p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p><p>Kube-proxy，主要负责为Pod对象提供代理。</p><p>Fluentd，主要负责日志收集、存储与查询。</p><p><strong>另外一种通俗的解释：（可以先往下学习，等学的差不多了，再来看更能理解）</strong></p><p>18张儿童插画让你秒懂Kubernetes</p><p>很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0b0aebb675f9c57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc457f68dfddb846.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。</p><p>每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-01e1f91dc2c50cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0c4f7abbcfb19b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>(Docker)容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。</p><p>对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc6d941e7e393395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。</p><p>就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。</p><p>“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31cf971fbdeb8ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2fa9619ea6e41154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“我是 Phippy。”小应用程序说。</p><p>“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-57696b2530f1b594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9a5206fa58576b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-d816b7b515e39c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。</p><p>但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。</p><p>Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2d75cd71125c0e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢?”</p><p>“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-18849e1d5226165e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。</p><p>通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5a3010b48e9fba80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。</p><p>Kube 船长慈祥地笑了笑：“我正好有一样东西。”</p><p>他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你!”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-e1eab190db313f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>服务告知 Kubernetes 环境的其余部分(包括其他 Pod 和 Replication Controller)你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。</p><p>其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3a92c6383ee31771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了***的朋友。</p><p>有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。</p><p>“你为什么这么伤心呢?”Goldie 问道。</p><p>“我喜欢这个礼物，但我没有地方可以放它!”Phippy 抽噎道。</p><p>但 Goldie 知道该怎么做。“为什么不把它放入卷中呢?”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1cc777d3edf587a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。</p><p>Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴(Goldie 和每个克隆人都同样令人愉悦)。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。</p><p>“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-30ee26dd6873f48d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。</p><p>Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。</p><p>所以 Phippy 从此过上了幸福的生活。</p><p>转自：<a href="https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）" target="_blank" rel="noopener">https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门实践</title>
      <link href="/2019/07/15/docker-introductory-practice/"/>
      <url>/2019/07/15/docker-introductory-practice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>$$</p><h1 id="前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）"><a href="#前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）" class="headerlink" title="前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）"></a>前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）</h1><h1 id="虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）"><a href="#虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）" class="headerlink" title="虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）"></a>虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）</h1><h1 id="本机：192-168-0-5-1-Docker安装与启动"><a href="#本机：192-168-0-5-1-Docker安装与启动" class="headerlink" title="本机：192.168.0.5 1. Docker安装与启动"></a>本机：192.168.0.5 1. Docker安装与启动</h1><p>$$</p></blockquote><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1 安装Docker"></a>1.1 安装Docker</h2><p>​    (1)yum包更新到最新</p><p>  （2）安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper屈都依赖的</p><blockquote><p>​       </p><pre><code> sudo yum install -y  yum-utils devicemapper-persistent-data lvm2</code></pre></blockquote><p>​    (3) 设置yum源为阿里云</p><blockquote><p>​        <code>sudo yum-coonfig-manager --add-repo</code>        </p><p>[]: <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></blockquote><p>​    (4) 安装docker</p><blockquote><p>​        <code>sudo yum install docker-ce</code></p></blockquote><p>​    (5) 查看版本</p><blockquote><p>​        <code>docker -v</code></p></blockquote><h2 id="1-2-设置ustc的镜像"><a href="#1-2-设置ustc的镜像" class="headerlink" title="1.2 设置ustc的镜像"></a>1.2 设置ustc的镜像</h2><p>​    (1) 编辑该文件</p><blockquote><p>​        vi /etc/docker/daemon.json</p></blockquote><p>​    (2) 该文件中输入如下内容：</p><blockquote><p>​       </p><pre><code> {​        “registry-mirrors”:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]​        }</code></pre></blockquote><h2 id="1-3-Docker的启动与停止"><a href="#1-3-Docker的启动与停止" class="headerlink" title="1.3 Docker的启动与停止"></a>1.3 Docker的启动与停止</h2><p>​      <strong>systemctl</strong> 命令是系统服务管理器指令</p><blockquote><p>​        启动docker</p><p>​            systemctl start docker</p><p>​        停止docker</p><p>​            systemctl stop docker</p><p>​        重启docker</p><p>​            systemctl restart docker</p><p>​        查看docker状态</p><p>​            systemctl status docker</p><p>​        开机启动</p><p>​            systemctl enable docker</p><p>​        查看docker概要信息</p><p>​            docker  info</p></blockquote><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><h2 id="2-1-镜像相关命令"><a href="#2-1-镜像相关命令" class="headerlink" title="2.1 镜像相关命令"></a>2.1 镜像相关命令</h2><h3 id="2-1-1-查看镜像"><a href="#2-1-1-查看镜像" class="headerlink" title="2.1.1 查看镜像"></a>2.1.1 查看镜像</h3><blockquote><p>​        docker images</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f93cb5e0123a841f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-2-搜索镜像"><a href="#2-1-2-搜索镜像" class="headerlink" title="2.1.2 搜索镜像"></a>2.1.2 搜索镜像</h3><blockquote><p>​        docker search 镜像名称</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-8b9d9f04b51c22a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-3-拉取镜像"><a href="#2-1-3-拉取镜像" class="headerlink" title="2.1.3 拉取镜像"></a>2.1.3 拉取镜像</h3><blockquote><p>​        docker pull  镜像名称</p></blockquote><p>​        例如  docker  pull  centos:7</p><h3 id="2-1-4-删除镜像"><a href="#2-1-4-删除镜像" class="headerlink" title="2.1.4 删除镜像"></a>2.1.4 删除镜像</h3><blockquote><p>​        docker  rmi  镜像ID</p></blockquote><p>​        删除所有镜像：docker rmi  ‘docker  images  -q’</p><h2 id="2-2-容器相关命令"><a href="#2-2-容器相关命令" class="headerlink" title="2.2 容器相关命令"></a>2.2 容器相关命令</h2><h2 id="2-2-1-查看容器"><a href="#2-2-1-查看容器" class="headerlink" title="2.2.1 查看容器"></a>2.2.1 查看容器</h2><blockquote><p>​        查看正在运行容器：  docker  ps</p><p>​        查看所有容器： docker  ps  -a</p><p>​        查看最后一次运行容器： docker ps -1</p><p>​        查看停止容器： docker ps -f status=exited</p></blockquote><h3 id="2-2-2-创建与启动容器"><a href="#2-2-2-创建与启动容器" class="headerlink" title="2.2.2 创建与启动容器"></a>2.2.2 创建与启动容器</h3><blockquote><p>​        创建容器命令：docker run</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f47a717be5859766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​        (1) 交互式方式创建容器</p><blockquote><p>​            docker  run  -it  –name=容器名称  镜像名称：标签  /bin/bas</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08c91e9104339b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​              此时，创建完毕后直接进入。</p><p>​              进入容器后exit退出，容器状态自动变为exited.</p><p>​        (2) 守护式方式创建容器</p><blockquote><p>​                docker  run  -di  –name=容器名称  镜像名称：标签</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31bd00e3d1c6470b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                此时，创建完毕后未进入容器</p><p>​                登陆守护方式容器：docker exec -it 容器名称（或者ID） /bin/bash</p><p>​                注意：本次创建容器时，即使上面交互式方式创建的容器mycentos已经关闭，此时仍然不能本次容器也为mycentos!!!</p><h3 id="2-2-3-停止与启动容器"><a href="#2-2-3-停止与启动容器" class="headerlink" title="2.2.3 停止与启动容器"></a>2.2.3 停止与启动容器</h3><blockquote><p>​        停止容器：docker  stop  容器名称（或者ID）</p><p>​        启动容器：docker  start  容器名称（或者ID）</p></blockquote><h3 id="2-2-4-文件拷贝"><a href="#2-2-4-文件拷贝" class="headerlink" title="2.2.4 文件拷贝"></a>2.2.4 文件拷贝</h3><blockquote><p>将文件拷贝到容器内：docker  cp  需要拷贝文件或目录  容器名称:容器目录</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1c82c75233452cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>将文件拷贝出容器外：docker  cp  容器名称:容器目录  需要拷贝文件或目录</p></blockquote><h3 id="2-2-5-目录挂载"><a href="#2-2-5-目录挂载" class="headerlink" title="2.2.5 目录挂载"></a>2.2.5 目录挂载</h3><p><img src="https://upload-images.jianshu.io/upload_images/17169295-be3d71e849f42d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-6-查看容器IP地址"><a href="#2-2-6-查看容器IP地址" class="headerlink" title="2.2.6 查看容器IP地址"></a>2.2.6 查看容器IP地址</h3><blockquote><p>​            docker  inspect 容器名称（或者ID）</p></blockquote><p>直接查找到IP地址方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08d215cdd9404acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-7-删除容器"><a href="#2-2-7-删除容器" class="headerlink" title="2.2.7 删除容器"></a>2.2.7 删除容器</h3><blockquote><p>​        docker  rm  容器名称（或者ID）</p></blockquote><p>​        <strong>注意：1. 与删除镜像区别（删除镜像：docker  rmi  镜像ID）</strong></p><p>​                  <strong>2. 在删除镜像时，要把对应全部创建的容器删除才可以删除镜像！</strong></p><h1 id="3-应用部署"><a href="#3-应用部署" class="headerlink" title="3. 应用部署"></a>3. 应用部署</h1><h2 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h2><p>​    （1） 拉取mysql镜像</p><blockquote><p>​                docker  pull centos/mysql-57-centos7</p></blockquote><p>​    （2） 创建容器</p><blockquote><p>​                docker  run  -di  –name=tensquare_mysql  -p  33306:3306  -e  MYSQL_PASSWORD=123456  mysql</p></blockquote><p>​                -p  代表端口映射，格式为  宿主机映射端口：容器运行端口</p><p>​                -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的密码</p><p>​    （3） 进入mysql容器</p><blockquote><p>​                  docker  exec  -it  tensquare_mysql  /bin/bash</p></blockquote><p>​    （4） 登陆mysql</p><blockquote><p>​                mysql  -u  root  -p</p></blockquote><p>​    （5） 远程登陆mysql</p><p>​                连接宿主机IP并指定端口为33306，这样就可以操作容器的3306端口。</p><h2 id="3-2-tomcat部署"><a href="#3-2-tomcat部署" class="headerlink" title="3.2 tomcat部署"></a>3.2 tomcat部署</h2><p>​    （1） 拉取镜像</p><blockquote><p>​                    docker  pull  tomcat:7-jre7</p></blockquote><p>​        (2) 创建容器</p><p>​                    创建容器  -p 表示地址映射</p><blockquote><p>​                    docker  run  -di  –name=mytomcat  -p  9000:8080  -v /usr/local/webapps:/usr/local/tomcat/webapps  tomcat:7-jre7</p></blockquote><p>​      （3） 进入mysql容器</p><blockquote><p>​                    docker  exec  -it  mytomcat  /bin/bash</p></blockquote><p>​      （4） 远程访问：192.168.0.19:9000/index.jsp</p><h2 id="3-3-Nginx部署"><a href="#3-3-Nginx部署" class="headerlink" title="3.3 Nginx部署"></a>3.3 Nginx部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull  nginx</p></blockquote><p>​        (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=mynginx  -p  80:80  nginx</p></blockquote><h2 id="3-4-Redis部署"><a href="#3-4-Redis部署" class="headerlink" title="3.4 Redis部署"></a>3.4 Redis部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull redis</p></blockquote><p>​          (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=myredis  -p  6379:6379  redis</p></blockquote><h1 id="4-迁移与备份"><a href="#4-迁移与备份" class="headerlink" title="4. 迁移与备份"></a>4. 迁移与备份</h1><h2 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1  容器保存为镜像"></a>4.1  容器保存为镜像</h2><blockquote><p>​            docker  commit  mynginx  mynginx_i</p></blockquote><h2 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2  镜像备份"></a>4.2  镜像备份</h2><blockquote><p>​            docker  save  -o  mynginx.tar  mynginx_i</p></blockquote><h3 id="4-3-镜像恢复与迁移"><a href="#4-3-镜像恢复与迁移" class="headerlink" title="4.3  镜像恢复与迁移"></a>4.3  镜像恢复与迁移</h3><blockquote><p>​            docker  load  -i  mynginx.tar</p></blockquote><p>​            -i  输入的文件</p><blockquote><p>​            docker  images  可看到镜像已恢复</p></blockquote><h1 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. Dockerfile</h1><h2 id="5-1-什么是Dockerfile"><a href="#5-1-什么是Dockerfile" class="headerlink" title="5.1 什么是Dockerfile"></a>5.1 什么是Dockerfile</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-a222a077dc4601f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-6bf066c4b2fcff21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-3-使用脚本创建镜像"><a href="#5-3-使用脚本创建镜像" class="headerlink" title="5.3 使用脚本创建镜像"></a>5.3 使用脚本创建镜像</h2><p>​        （1）创建目录</p><blockquote><p>​                mkdir -p /usr/local/dockerjdk8</p></blockquote><p>​        （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器中/usr/local/dockerjdk8目录</p><p>​        （3）在dockerjdk8目录下创建文件Dockerfile    vi  Dockerfile</p><blockquote><p>​                    #依赖镜像名称和ID</p><p>​                    FROM centos7</p><p>​                    #指定镜像创建者</p><p>​                    MAINTAINER FENCO</p><p>​                    #切换工作目录</p><p>​                    WORKDIR  /usr</p><p>​                    RUN  mkdir  /usr/local/java</p><p>​                    #ADD  是相对路径jar,把java添加到容器</p><p>​                    ADD  jdk-8u171-linux-x64.tar.gz  /usr/local/java/</p></blockquote><blockquote><p>​                    #配置java环境变量</p><p>​                    ENV  JAVA_HOME   /usr/local/java/jdk1.8.0_171</p><p>​                    ENV  JRE_HOME   $JAVA_HOME/jre</p><p>​                    ENV  CLASSPATH   $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</p><p>​                    ENV  PATH  $JAVA_HOME/bin:$PATH</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-077f15b821721ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                            <strong>注意：由于创建jdk1.8镜像用到了docker.io/centos镜像，所以必须保证本地有该镜像。</strong></p><p>​             (4) 执行命令构建镜像</p><blockquote><p>​                       在dockerjdk8目录下执行：    docker   build  -t=’jdk1.8’  .           最后面的点，表示该根目录</p></blockquote><p>​            (5) 查看镜像是否建立完成</p><blockquote><p>​                        docker  images</p></blockquote><h1 id="6-Docker私有仓库"><a href="#6-Docker私有仓库" class="headerlink" title="6. Docker私有仓库"></a>6. Docker私有仓库</h1><h2 id="6-1-私有仓库的搭建及配置"><a href="#6-1-私有仓库的搭建及配置" class="headerlink" title="6.1 私有仓库的搭建及配置"></a>6.1 私有仓库的搭建及配置</h2><p>​    （1） 拉取私有仓库镜像</p><blockquote><p>​        docker pull registry</p></blockquote><p>​      (2)  启动私有仓库容器</p><blockquote><p>​            docker  run  -di  –name=registry  -p  5000:5000  registry</p></blockquote><p>​     (3) 用浏览器访问：<a href="http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。" target="_blank" rel="noopener">http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。</a></p><p>  （4）修改daemon.json</p><blockquote><p>​            vi  /etc/docker/daemon.json</p><p>​            添加以下内容并保存退出。</p><p>​            {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>  （5） 重启docker服务</p><blockquote><p>​            systemctl restart  docker</p></blockquote><h2 id="6-2-镜像的上传及下载到私有仓库"><a href="#6-2-镜像的上传及下载到私有仓库" class="headerlink" title="6.2 镜像的上传及下载到私有仓库"></a>6.2 镜像的上传及下载到私有仓库</h2><h3 id="6-2-1镜像的上传"><a href="#6-2-1镜像的上传" class="headerlink" title="6.2.1镜像的上传"></a>6.2.1镜像的上传</h3><p>​    （1） 标记次镜像为私有仓库的镜像</p><blockquote><p>​                docker tag jdk1.8 192.168.0.19:5000/jdk1.8</p></blockquote><p>​      (2) 上传标记镜像</p><blockquote><p>​                首先，上一步重启了docker服务，所以里面的registry容器也需要启动下。</p><p>​                然后执行上传：docker  push  192.168.0.19:5000/jdk1.8</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4e37943897353c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="6-2-2-镜像的下载"><a href="#6-2-2-镜像的下载" class="headerlink" title="6.2.2 镜像的下载"></a>6.2.2 镜像的下载</h3><p><strong>在另外一台虚拟机中安装docker（192.168.0.21）</strong></p><p>​    （1）修改daemon.json</p><blockquote><p>​                vi  /etc/docker/daemon.json</p><p>​                添加以下内容并保存退出。</p><p>​                {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>​    （2） 重启docker服务</p><blockquote><p>​                systemctl restart  docker</p></blockquote><p>​     (3) 下载标记镜像</p><blockquote><p>​                然后执行下载：docker  pull  192.168.0.19:5000/jdk1.8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
