<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人生经验</title>
      <link href="/2019/11/14/thinking/"/>
      <url>/2019/11/14/thinking/</url>
      
        <content type="html"><![CDATA[<ol><li><p>除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。</p></li><li><p>沉不下心看书，浮躁和焦虑，都是因为年纪渐长，不信正道而太重功利导致的。</p></li><li><p>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p></li><li><p>一个人明白自己能做什么远比自己想做什么重要得多，前者需要给自己设定一个现实的疆域，是一种尽力而为的勤奋，后者是任性催生的热情，往往来自于对世界的无知和自负。一个人，一定要清楚地认识自己。</p></li><li><p>天下没有免费的午餐。想得到任何东西之前都要先问问自己，是否付得起相应的代价。</p></li><li><p>在早上把你叫醒的，不应该是闹钟，不应该是闹钟，而应该是昨天早睡。</p></li><li><p>太用力的人，跑不远，别把人生的马拉松当成百米冲刺；太用力的爱不仅让自己累，也让身边的人累，最终难以圆满。</p></li><li><p>永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。圈子不同，不必强融。</p></li><li><p>一定要去掌控自己的生活，而不要让生活带着你走。</p></li><li><p>蔡康永曾说，你15岁的时候觉得游泳难，放弃游泳，到18岁遇见一个你喜欢的人约你去游泳，你只好说：“我不会耶”。你18岁觉得英语难，放弃英语，你28岁遇到了一份非常好也很适合你但是要求会英语的工作，你只好说“我不会耶”。出来混总是要还的，前期偷懒，后期肯定要花数倍的精力来弥补，更遗憾的是，不一定补得上。人生最可怕的事，是一边后悔一边生活。</p></li><li><p>婚姻里的指责和抱怨不是因为“我爱你”，而是因为“我情绪管理不好”。</p></li></ol><p>指责不是爱，而是婚姻的杀手。</p><ol start="12"><li>父母的话不全是对的，父母的爱不全是无私的。</li><li>成熟不等于世故，知世故而不世故，才是最善良的成熟。</li><li>你其实并没有想象中那么依赖父母，但父母依赖你的程度远远超过于你的想象。</li><li>尽量不给别人添麻烦，别人最好也别麻烦我。这句话不是冷漠，是成熟。</li><li>分开的时候一定要用力告别，因为说再见，也许真的是再也不见。</li><li>当你的学业、工作、生活不顺利的时候，切记不要把爱情当成你的救命稻草。</li><li>我们总是喜欢拿顺其自然来敷衍人生道路上的荆棘坎坷，却很少承认，真正的顺其自然，其实是竭尽所能之后的不强求，而非两手一摊的不作为。</li><li>破不说破，知人不评人，知理不争论。</li><li>刻薄嘴欠和幽默是两回事，口无遮拦和坦率是两回事，没有教养和随性是两回事。有事情是要说出来的，不要等着对方去领悟，因为对方不是你，不知道你想要什么，等到最后只能是伤心和失望，尤其是感情。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes_learningng_01</title>
      <link href="/2019/11/13/Kubernetes-learningng-01/"/>
      <url>/2019/11/13/Kubernetes-learningng-01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kubernetes的介绍"><a href="#1-Kubernetes的介绍" class="headerlink" title="1.Kubernetes的介绍"></a>1.Kubernetes的介绍</h2><h3 id="1-1Kubernetes与Docker"><a href="#1-1Kubernetes与Docker" class="headerlink" title="1.1Kubernetes与Docker"></a>1.1Kubernetes与Docker</h3><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C1.png" alt=""></p><p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC(Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源)有关的容器技术。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C2.png" alt=""></p><p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C3.png" alt=""></p><p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p><p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p><img src="G:%5Cblog%5Csource_posts%5Cimgs%5C4.png" alt=""></p><p>Open Source，开源</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-03f79be8f1c3a859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Solomon Hykes</p><p>不开则已，一开惊人。</p><p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p><p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p><p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-65f6a350d2889e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-dd4eeed33ca1d759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。</p><p>而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化。</strong></p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4790d914c6bbdd53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-79394519ff0633de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>我们具体来看看Docker。Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“<strong>一次构建，到处运行（Build once，run anywhere）</strong>”。</p><p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p><p>想要搞懂Docker，其实看它的两句口号就行。</p><p>第一句，是“<strong>Build, Ship and Run</strong>”。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-ada467dd294a3fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>也就是，“搭建、发送、运行”，三板斧。</p><p>举个例子：</p><p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-853f90a47874564c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p><p>但是，跑来一个老巫婆，教会我一种魔法。</p><p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-753393ea28196c31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5c237217f6bd517d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>怎么样？是不是很神奇？</p><p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p><p>Docker技术的三大核心概念，分别是：</p><p><strong>镜像（Image）</strong></p><p><strong>容器（Container）</strong></p><p><strong>仓库（Repository）</strong></p><p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p><p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p><p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p><p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p><p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9ca3a319ce4d91ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>于是乎，就变成了一个大的公共仓库。</p><p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p><p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p><p>所以，Docker Registry服务对镜像的管理是非常严格的。</p><p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>好了，说完了Docker，我们再把目光转向K8S。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p><p>就在这个时候，K8S出现了。</p><p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f0aa142c93e879de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p><p>这个集群主要包括两个部分：</p><p><strong>一个Master节点（主节点）</strong></p><p><strong>一群Node节点（计算节点）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-cca00815aa29d21c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p><p>深入来看这两种节点。</p><p>首先是<strong>Master节点。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1bc2e7499cbe5dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p><p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p><p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p><p>Controller manager负责管理控制器，相当于“大总管”。</p><p>然后是<strong>Node节点</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3538dfa59c20c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p><p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p><p>Docker，不用说了，创建容器的。</p><p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p><p>Kube-proxy，主要负责为Pod对象提供代理。</p><p>Fluentd，主要负责日志收集、存储与查询。</p><p><strong>另外一种通俗的解释：（可以先往下学习，等学的差不多了，再来看更能理解）</strong></p><p>18张儿童插画让你秒懂Kubernetes</p><p>很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0b0aebb675f9c57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc457f68dfddb846.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。</p><p>每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-01e1f91dc2c50cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-0c4f7abbcfb19b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>(Docker)容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。</p><p>对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-bc6d941e7e393395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。</p><p>就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。</p><p>“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31cf971fbdeb8ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2fa9619ea6e41154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>“我是 Phippy。”小应用程序说。</p><p>“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-57696b2530f1b594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-9a5206fa58576b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-d816b7b515e39c4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。</p><p>但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。</p><p>Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-2d75cd71125c0e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢?”</p><p>“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-18849e1d5226165e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。</p><p>通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-5a3010b48e9fba80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。</p><p>Kube 船长慈祥地笑了笑：“我正好有一样东西。”</p><p>他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你!”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-e1eab190db313f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>服务告知 Kubernetes 环境的其余部分(包括其他 Pod 和 Replication Controller)你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。</p><p>其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-3a92c6383ee31771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了***的朋友。</p><p>有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。</p><p>“你为什么这么伤心呢?”Goldie 问道。</p><p>“我喜欢这个礼物，但我没有地方可以放它!”Phippy 抽噎道。</p><p>但 Goldie 知道该怎么做。“为什么不把它放入卷中呢?”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1cc777d3edf587a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。</p><p>Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴(Goldie 和每个克隆人都同样令人愉悦)。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。</p><p>“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-30ee26dd6873f48d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。</p><p>Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。</p><p>所以 Phippy 从此过上了幸福的生活。</p><p>转自：<a href="https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）" target="_blank" rel="noopener">https://www.cnblogs.com/kouryoushine/articles/8007648.html（站在浪潮之巅）</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/2019/11/13/tags/"/>
      <url>/2019/11/13/tags/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2019/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2019/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：搭建自己的博客简介"><a href="#第一章：搭建自己的博客简介" class="headerlink" title="第一章：搭建自己的博客简介"></a>第一章：搭建自己的博客简介</h1><p>内容<br>内容内容内容内容内容内容内容</p><p>内容内容内容内容</p><p>内容内容内容内容</p><p>内容内容内容内容</p><h1 id="第二章：搭建Hexo博客过程"><a href="#第二章：搭建Hexo博客过程" class="headerlink" title="第二章：搭建Hexo博客过程"></a>第二章：搭建Hexo博客过程</h1><p>内容内容内容</p><p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p><p>内容内容</p><p>内容内容内容内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h2 id="详情点击：www-fenco-cn"><a href="#详情点击：www-fenco-cn" class="headerlink" title="详情点击：www.fenco.cn"></a>详情点击：<a href="http://www.fenco.cn" target="_blank" rel="noopener">www.fenco.cn</a></h2>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/04/hello-world/"/>
      <url>/2019/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门实践</title>
      <link href="/2019/07/15/Docker-Introductory-Practice/"/>
      <url>/2019/07/15/Docker-Introductory-Practice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>$$</p><h1 id="前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）"><a href="#前提：-虚拟机1-CentOS7-192-168-0-19（与物理机桥接方式）" class="headerlink" title="前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）"></a>前提：   虚拟机1  CentOS7:192.168.0.19（与物理机桥接方式）</h1><h1 id="虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）"><a href="#虚拟机2-CentOS7-192-168-0-21（与物理机桥接方式）" class="headerlink" title="虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）"></a>虚拟机2  CentOS7:192.168.0.21（与物理机桥接方式）</h1><h1 id="本机：192-168-0-5-1-Docker安装与启动"><a href="#本机：192-168-0-5-1-Docker安装与启动" class="headerlink" title="本机：192.168.0.5 1. Docker安装与启动"></a>本机：192.168.0.5 1. Docker安装与启动</h1><p>$$</p></blockquote><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1 安装Docker"></a>1.1 安装Docker</h2><p>​    (1)yum包更新到最新</p><p>  （2）安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper屈都依赖的</p><blockquote><p>​       </p><pre><code> sudo yum install -y  yum-utils devicemapper-persistent-data lvm2</code></pre></blockquote><p>​    (3) 设置yum源为阿里云</p><blockquote><p>​        <code>sudo yum-coonfig-manager --add-repo</code>        </p><p>[]: <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></blockquote><p>​    (4) 安装docker</p><blockquote><p>​        <code>sudo yum install docker-ce</code></p></blockquote><p>​    (5) 查看版本</p><blockquote><p>​        <code>docker -v</code></p></blockquote><h2 id="1-2-设置ustc的镜像"><a href="#1-2-设置ustc的镜像" class="headerlink" title="1.2 设置ustc的镜像"></a>1.2 设置ustc的镜像</h2><p>​    (1) 编辑该文件</p><blockquote><p>​        vi /etc/docker/daemon.json</p></blockquote><p>​    (2) 该文件中输入如下内容：</p><blockquote><p>​       </p><pre><code> {​        “registry-mirrors”:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]​        }</code></pre></blockquote><h2 id="1-3-Docker的启动与停止"><a href="#1-3-Docker的启动与停止" class="headerlink" title="1.3 Docker的启动与停止"></a>1.3 Docker的启动与停止</h2><p>​      <strong>systemctl</strong> 命令是系统服务管理器指令</p><blockquote><p>​        启动docker</p><p>​            systemctl start docker</p><p>​        停止docker</p><p>​            systemctl stop docker</p><p>​        重启docker</p><p>​            systemctl restart docker</p><p>​        查看docker状态</p><p>​            systemctl status docker</p><p>​        开机启动</p><p>​            systemctl enable docker</p><p>​        查看docker概要信息</p><p>​            docker  info</p></blockquote><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><h2 id="2-1-镜像相关命令"><a href="#2-1-镜像相关命令" class="headerlink" title="2.1 镜像相关命令"></a>2.1 镜像相关命令</h2><h3 id="2-1-1-查看镜像"><a href="#2-1-1-查看镜像" class="headerlink" title="2.1.1 查看镜像"></a>2.1.1 查看镜像</h3><blockquote><p>​        docker images</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f93cb5e0123a841f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-2-搜索镜像"><a href="#2-1-2-搜索镜像" class="headerlink" title="2.1.2 搜索镜像"></a>2.1.2 搜索镜像</h3><blockquote><p>​        docker search 镜像名称</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-8b9d9f04b51c22a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-1-3-拉取镜像"><a href="#2-1-3-拉取镜像" class="headerlink" title="2.1.3 拉取镜像"></a>2.1.3 拉取镜像</h3><blockquote><p>​        docker pull  镜像名称</p></blockquote><p>​        例如  docker  pull  centos:7</p><h3 id="2-1-4-删除镜像"><a href="#2-1-4-删除镜像" class="headerlink" title="2.1.4 删除镜像"></a>2.1.4 删除镜像</h3><blockquote><p>​        docker  rmi  镜像ID</p></blockquote><p>​        删除所有镜像：docker rmi  ‘docker  images  -q’</p><h2 id="2-2-容器相关命令"><a href="#2-2-容器相关命令" class="headerlink" title="2.2 容器相关命令"></a>2.2 容器相关命令</h2><h2 id="2-2-1-查看容器"><a href="#2-2-1-查看容器" class="headerlink" title="2.2.1 查看容器"></a>2.2.1 查看容器</h2><blockquote><p>​        查看正在运行容器：  docker  ps</p><p>​        查看所有容器： docker  ps  -a</p><p>​        查看最后一次运行容器： docker ps -1</p><p>​        查看停止容器： docker ps -f status=exited</p></blockquote><h3 id="2-2-2-创建与启动容器"><a href="#2-2-2-创建与启动容器" class="headerlink" title="2.2.2 创建与启动容器"></a>2.2.2 创建与启动容器</h3><blockquote><p>​        创建容器命令：docker run</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-f47a717be5859766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​        (1) 交互式方式创建容器</p><blockquote><p>​            docker  run  -it  –name=容器名称  镜像名称：标签  /bin/bas</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08c91e9104339b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​              此时，创建完毕后直接进入。</p><p>​              进入容器后exit退出，容器状态自动变为exited.</p><p>​        (2) 守护式方式创建容器</p><blockquote><p>​                docker  run  -di  –name=容器名称  镜像名称：标签</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-31bd00e3d1c6470b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                此时，创建完毕后未进入容器</p><p>​                登陆守护方式容器：docker exec -it 容器名称（或者ID） /bin/bash</p><p>​                注意：本次创建容器时，即使上面交互式方式创建的容器mycentos已经关闭，此时仍然不能本次容器也为mycentos!!!</p><h3 id="2-2-3-停止与启动容器"><a href="#2-2-3-停止与启动容器" class="headerlink" title="2.2.3 停止与启动容器"></a>2.2.3 停止与启动容器</h3><blockquote><p>​        停止容器：docker  stop  容器名称（或者ID）</p><p>​        启动容器：docker  start  容器名称（或者ID）</p></blockquote><h3 id="2-2-4-文件拷贝"><a href="#2-2-4-文件拷贝" class="headerlink" title="2.2.4 文件拷贝"></a>2.2.4 文件拷贝</h3><blockquote><p>将文件拷贝到容器内：docker  cp  需要拷贝文件或目录  容器名称:容器目录</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-1c82c75233452cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>将文件拷贝出容器外：docker  cp  容器名称:容器目录  需要拷贝文件或目录</p></blockquote><h3 id="2-2-5-目录挂载"><a href="#2-2-5-目录挂载" class="headerlink" title="2.2.5 目录挂载"></a>2.2.5 目录挂载</h3><p><img src="https://upload-images.jianshu.io/upload_images/17169295-be3d71e849f42d3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-6-查看容器IP地址"><a href="#2-2-6-查看容器IP地址" class="headerlink" title="2.2.6 查看容器IP地址"></a>2.2.6 查看容器IP地址</h3><blockquote><p>​            docker  inspect 容器名称（或者ID）</p></blockquote><p>直接查找到IP地址方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/17169295-08d215cdd9404acc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-2-7-删除容器"><a href="#2-2-7-删除容器" class="headerlink" title="2.2.7 删除容器"></a>2.2.7 删除容器</h3><blockquote><p>​        docker  rm  容器名称（或者ID）</p></blockquote><p>​        <strong>注意：1. 与删除镜像区别（删除镜像：docker  rmi  镜像ID）</strong></p><p>​                  <strong>2. 在删除镜像时，要把对应全部创建的容器删除才可以删除镜像！</strong></p><h1 id="3-应用部署"><a href="#3-应用部署" class="headerlink" title="3. 应用部署"></a>3. 应用部署</h1><h2 id="3-1-MySQL部署"><a href="#3-1-MySQL部署" class="headerlink" title="3.1 MySQL部署"></a>3.1 MySQL部署</h2><p>​    （1） 拉取mysql镜像</p><blockquote><p>​                docker  pull centos/mysql-57-centos7</p></blockquote><p>​    （2） 创建容器</p><blockquote><p>​                docker  run  -di  –name=tensquare_mysql  -p  33306:3306  -e  MYSQL_PASSWORD=123456  mysql</p></blockquote><p>​                -p  代表端口映射，格式为  宿主机映射端口：容器运行端口</p><p>​                -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的密码</p><p>​    （3） 进入mysql容器</p><blockquote><p>​                  docker  exec  -it  tensquare_mysql  /bin/bash</p></blockquote><p>​    （4） 登陆mysql</p><blockquote><p>​                mysql  -u  root  -p</p></blockquote><p>​    （5） 远程登陆mysql</p><p>​                连接宿主机IP并指定端口为33306，这样就可以操作容器的3306端口。</p><h2 id="3-2-tomcat部署"><a href="#3-2-tomcat部署" class="headerlink" title="3.2 tomcat部署"></a>3.2 tomcat部署</h2><p>​    （1） 拉取镜像</p><blockquote><p>​                    docker  pull  tomcat:7-jre7</p></blockquote><p>​        (2) 创建容器</p><p>​                    创建容器  -p 表示地址映射</p><blockquote><p>​                    docker  run  -di  –name=mytomcat  -p  9000:8080  -v /usr/local/webapps:/usr/local/tomcat/webapps  tomcat:7-jre7</p></blockquote><p>​      （3） 进入mysql容器</p><blockquote><p>​                    docker  exec  -it  mytomcat  /bin/bash</p></blockquote><p>​      （4） 远程访问：192.168.0.19:9000/index.jsp</p><h2 id="3-3-Nginx部署"><a href="#3-3-Nginx部署" class="headerlink" title="3.3 Nginx部署"></a>3.3 Nginx部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull  nginx</p></blockquote><p>​        (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=mynginx  -p  80:80  nginx</p></blockquote><h2 id="3-4-Redis部署"><a href="#3-4-Redis部署" class="headerlink" title="3.4 Redis部署"></a>3.4 Redis部署</h2><p>​        （1） 拉取镜像</p><blockquote><p>​                    docker  pull redis</p></blockquote><p>​          (2) 创建容器</p><blockquote><p>​                    创建容器  -p 表示地址映射</p><p>​                    docker  run  -di  –name=myredis  -p  6379:6379  redis</p></blockquote><h1 id="4-迁移与备份"><a href="#4-迁移与备份" class="headerlink" title="4. 迁移与备份"></a>4. 迁移与备份</h1><h2 id="4-1-容器保存为镜像"><a href="#4-1-容器保存为镜像" class="headerlink" title="4.1  容器保存为镜像"></a>4.1  容器保存为镜像</h2><blockquote><p>​            docker  commit  mynginx  mynginx_i</p></blockquote><h2 id="4-2-镜像备份"><a href="#4-2-镜像备份" class="headerlink" title="4.2  镜像备份"></a>4.2  镜像备份</h2><blockquote><p>​            docker  save  -o  mynginx.tar  mynginx_i</p></blockquote><h3 id="4-3-镜像恢复与迁移"><a href="#4-3-镜像恢复与迁移" class="headerlink" title="4.3  镜像恢复与迁移"></a>4.3  镜像恢复与迁移</h3><blockquote><p>​            docker  load  -i  mynginx.tar</p></blockquote><p>​            -i  输入的文件</p><blockquote><p>​            docker  images  可看到镜像已恢复</p></blockquote><h1 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. Dockerfile</h1><h2 id="5-1-什么是Dockerfile"><a href="#5-1-什么是Dockerfile" class="headerlink" title="5.1 什么是Dockerfile"></a>5.1 什么是Dockerfile</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-a222a077dc4601f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/17169295-6bf066c4b2fcff21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-3-使用脚本创建镜像"><a href="#5-3-使用脚本创建镜像" class="headerlink" title="5.3 使用脚本创建镜像"></a>5.3 使用脚本创建镜像</h2><p>​        （1）创建目录</p><blockquote><p>​                mkdir -p /usr/local/dockerjdk8</p></blockquote><p>​        （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器中/usr/local/dockerjdk8目录</p><p>​        （3）在dockerjdk8目录下创建文件Dockerfile    vi  Dockerfile</p><blockquote><p>​                    #依赖镜像名称和ID</p><p>​                    FROM centos7</p><p>​                    #指定镜像创建者</p><p>​                    MAINTAINER FENCO</p><p>​                    #切换工作目录</p><p>​                    WORKDIR  /usr</p><p>​                    RUN  mkdir  /usr/local/java</p><p>​                    #ADD  是相对路径jar,把java添加到容器</p><p>​                    ADD  jdk-8u171-linux-x64.tar.gz  /usr/local/java/</p></blockquote><blockquote><p>​                    #配置java环境变量</p><p>​                    ENV  JAVA_HOME   /usr/local/java/jdk1.8.0_171</p><p>​                    ENV  JRE_HOME   $JAVA_HOME/jre</p><p>​                    ENV  CLASSPATH   $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</p><p>​                    ENV  PATH  $JAVA_HOME/bin:$PATH</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-077f15b821721ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​                            <strong>注意：由于创建jdk1.8镜像用到了docker.io/centos镜像，所以必须保证本地有该镜像。</strong></p><p>​             (4) 执行命令构建镜像</p><blockquote><p>​                       在dockerjdk8目录下执行：    docker   build  -t=’jdk1.8’  .           最后面的点，表示该根目录</p></blockquote><p>​            (5) 查看镜像是否建立完成</p><blockquote><p>​                        docker  images</p></blockquote><h1 id="6-Docker私有仓库"><a href="#6-Docker私有仓库" class="headerlink" title="6. Docker私有仓库"></a>6. Docker私有仓库</h1><h2 id="6-1-私有仓库的搭建及配置"><a href="#6-1-私有仓库的搭建及配置" class="headerlink" title="6.1 私有仓库的搭建及配置"></a>6.1 私有仓库的搭建及配置</h2><p>​    （1） 拉取私有仓库镜像</p><blockquote><p>​        docker pull registry</p></blockquote><p>​      (2)  启动私有仓库容器</p><blockquote><p>​            docker  run  -di  –name=registry  -p  5000:5000  registry</p></blockquote><p>​     (3) 用浏览器访问：<a href="http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。" target="_blank" rel="noopener">http://192.168.0.19:5000/v2/_catalog看到{“repositories”:[]}表示私有仓库搭建成功内容为空。</a></p><p>  （4）修改daemon.json</p><blockquote><p>​            vi  /etc/docker/daemon.json</p><p>​            添加以下内容并保存退出。</p><p>​            {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>  （5） 重启docker服务</p><blockquote><p>​            systemctl restart  docker</p></blockquote><h2 id="6-2-镜像的上传及下载到私有仓库"><a href="#6-2-镜像的上传及下载到私有仓库" class="headerlink" title="6.2 镜像的上传及下载到私有仓库"></a>6.2 镜像的上传及下载到私有仓库</h2><h3 id="6-2-1镜像的上传"><a href="#6-2-1镜像的上传" class="headerlink" title="6.2.1镜像的上传"></a>6.2.1镜像的上传</h3><p>​    （1） 标记次镜像为私有仓库的镜像</p><blockquote><p>​                docker tag jdk1.8 192.168.0.19:5000/jdk1.8</p></blockquote><p>​      (2) 上传标记镜像</p><blockquote><p>​                首先，上一步重启了docker服务，所以里面的registry容器也需要启动下。</p><p>​                然后执行上传：docker  push  192.168.0.19:5000/jdk1.8</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17169295-4e37943897353c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="6-2-2-镜像的下载"><a href="#6-2-2-镜像的下载" class="headerlink" title="6.2.2 镜像的下载"></a>6.2.2 镜像的下载</h3><p><strong>在另外一台虚拟机中安装docker（192.168.0.21）</strong></p><p>​    （1）修改daemon.json</p><blockquote><p>​                vi  /etc/docker/daemon.json</p><p>​                添加以下内容并保存退出。</p><p>​                {“insecure-registries”:[“192.168.0.19:5000”]}    此步用于让docker信任私有仓库地址</p></blockquote><p>​    （2） 重启docker服务</p><blockquote><p>​                systemctl restart  docker</p></blockquote><p>​     (3) 下载标记镜像</p><blockquote><p>​                然后执行下载：docker  pull  192.168.0.19:5000/jdk1.8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
